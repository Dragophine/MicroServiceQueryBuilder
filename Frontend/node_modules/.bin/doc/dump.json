[
  {
    "__docId__": 0,
    "kind": "file",
    "name": "App/alerting/alerting.js",
    "content": "'use strict';\n\nangular.module('queryBuilder.alerting', ['ngRoute', 'queryBuilder.services'])\n\n.config(['$routeProvider', function($routeProvider) {\n  $routeProvider.when('/alerting', {\n    templateUrl: 'alerting/alerting.html'\n  });\n}])\n/**\n   * This controller handles the main operation in the user interface.\n   * It configures and handle all actions in the alert view.\n   * \n   * @version 1.0.0\n   */\n.controller('alertingCtrl', ['$requests',\n\tfunction($requests) {\n\tvar self = this;\n\t\n    /**\n     * Holds name from alert.\n     * @type {string}\n     */\n\tself.name = \"\";\n    /**\n     * Holds type from alert. Examples: int, string,...\n     * @type {string}\n     */\n\tself.type = \"\";\n    /**\n     * Holds filter type from alert. Examples: in, like,...\n     * @type {string}\n     */\n\tself.filterType = \"\";\n    /**\n     * Holds email address from alert.\n     * @type {string}\n     */\n\tself.email = \"\";\n    /**\n     * Holds limit value from alert.\n     * @type {string}\n     */\n\tself.value = \"\";\n    /**\n     * If a value from alert is missing or invalid in save dialog a message will be stored\n     * in this array.\n     * @type {array}\n     */\n\tself.text = [];\n    /**\n     * Store the name from loaded alert. When an alert has been loaded, you have the option\n     * to create a new alert when saving or to rewrite the loaded alert.\n     * @type {string}\n     */\n\tself.selectedAlertName = \"\";\n    /**\n     * Store all queries which can be selected in alert view.\n     * @type {array}\n     */\n\tself.queries = [];\n    /**\n     * Holds selected query from alert.\n     * @type {string}\n     */\n\tself.selectedQuery = \"\";\t\n\t/**\n\t * Modal dialog for missing or invalid data.\n     * @type {object}\n\t */\n\tvar missingDataModal = document.getElementById('myModalMissingData');\n\t/**\n\t * Ok-button from modal dialog for missing or invalid data.\n     * @type {object}\n\t */\n\tvar missingDataOkButton = document.getElementById(\"missingDataOk\");\n\t\n\t/**\n\t * Close modal dialog if user select the ok-button in dialog.\n\t */\n\tmissingDataOkButton.onclick = function() {\n\t\tmissingDataModal.style.display = \"none\";\n\t}\n\t\n\t /**\n     * Holds the error string which is displayed to the user.\n     * The table is only shown when the hasError property is set to TRUE.\n     * @type {string}\n     */\n\tself.error = \"\";\n\t\n\t /**\n     * If there was an error during the execution of the query this is set to \n     * true and the error will be displayed. Otherwise the table will be displayed.\n     * @type {boolean}\n     */\n\tself.hasError = false;\n\t\n\t/**\n\t * Callback from delete/save alert call. If query was successful refresh alert names.\n\t * Otherwise print error.\n\t *\n\t * @param {boolean} $success - true when there are no errors.\n\t * @param {Object} $data - the requested data.\n     * @param {number} $status - the actual server status.\n\t */\n\tself.callback = function($success, $data, $status) {\n\t\tself.hasError = !$success;\n\t\tif($success)\n\t\t{\n\t\t\t$requests.getAllAlertNames(self.getAlertsCB);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tself.error = $data;\n\t\t}\n\t}\n\t\n\t/**\n\t * Callback from get all nodes call. If query was successful save data in variable self.queries.\n\t * Otherwise print error.\n\t * \n\t * @param {boolean} $success - true when there are no errors.\n\t * @param {Object} $data - the requested data (In this case the queries).\n     * @param {number} $status - the actual server status.\n\t */\n\tself.queriesCB = function($success, $data, $status){\n\t\tself.hasError = !$success;\n\t\tif($success)\n\t\t{\n\t\t\tself.queries = $data;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tself.error = $data;\n\t\t}\n\t}\n\t$requests.loadAllQueries(self.queriesCB);\n\t\n\t/**\n\t * Callback from get query by name call. If query was successful save data in variable self.selectedQuery.\n\t * Otherwise print error.\n\t * \n\t * @param {boolean} $success - true when there are no errors.\n\t * @param {Object} $data - the requested data (In this case the query).\n     * @param {number} $status - the actual server status.\n\t */\n\tself.getQueryByNameCB = function($success, $data, $status){\n\t\tself.hasError = !$success;\n\t\tif($success){\n\t\t\tself.selectedQuery = $data.name;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tself.error = $data;\n\t\t}\n\t}\n\t\n\t/**\n\t * Callback from get all alert names call. If query was successful save data in variable self.existingAlerts.\n\t * Otherwise print error.\n\t * \n\t * @param {boolean} $success - true when there are no errors.\n\t * @param {Object} $data - the requested data (In this case the alert names).\n     * @param {number} $status - the actual server status.\n\t */\n\tself.getAlertsCB = function($success, $data, $status) {\n\t\tself.hasError = !$success;\n\t\tif($success){\n\t\t\tself.existingAlerts = $data;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tself.error = $data;\n\t\t}\n\t}\t\n\t$requests.getAllAlertNames(self.getAlertsCB);\n\t\n\t/**\n\t * Create new alert, if all fields are filled correctly.\n\t */\n    self.addAlert = function () {\n    \tcheckAllFieldsValidate(true);\n        if(self.text != \"\"){\n            missingDataModal.style.display = \"block\";\n        }\n        else\n\t\t{\n\t\t\t$requests.addAlert(self.name, self.selectedQuery, self.type, self.filterType,\n\t\t\tself.email, self.value, self.getAlertsCB);\n\t\t\t$requests.getAllAlertNames(self.getAlertsCB);\n\t\t\tself.resetValues();\n        }\n    };\n    \n\t/**\n\t * Save already existing alert, if all fields are filled correctly.\n\t */\n    self.saveAlert = function () {\n    \tcheckAllFieldsValidate(false);\n        if(self.text != \"\"){\n            missingDataModal.style.display = \"block\";\n        }\n        else\n\t\t{\n\t\t\t$requests.saveAlert(self.selectedAlertName, self.name, self.selectedQuery, self.type, self.filterType,\n\t\t\tself.email, self.value, self.callback);\n        }\n    };\n\t\n\t/**\n\t * Check if email address is correct.\n\t * \n\t * @param {string} email - email address from alert form.\n\t */\n\tfunction validateEmail(email) {\n\t\tvar re =  /^(([^<>()[\\]\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@(([^<>()[\\]\\.,;:\\s@\\\"]+\\.)+[^<>()[\\]\\.,;:\\s@\\\"]{2,})$/i;\n\t\treturn re.test(email);\n\t}\n\t\n\t/**\n\t * Check if the name from alert form already exists.\n\t */\n\tfunction existsNameAlready() {\n\t\t$requests.getAllAlertNames(self.getAlertsCB);\n\t\t\n\t\tfor (var i = 0; i < self.existingAlerts.length; i++)\n\t    {\n\t        if (self.existingAlerts[i].name === self.name)\n\t        {\n\t            return true;\n\t        }\n\t    }\n\t    return false;\t\t\n\t}\n\t\n\t/**\n\t * Check if all fields in alert form are correctly filled.\n\t * \n\t * @param {boolean} $checkIfNameExists - Is it necessary to check the name.\n\t */\n\tfunction checkAllFieldsValidate($checkIfNameExists) {\n    \tself.text = [];\n\t\tif($checkIfNameExists && (self.name === null || self.name === \"\"))\n\t\t{\n            self.text.push(\"Bitte geben Sie einen Namen ein.\");\n        }\n\t\telse if($checkIfNameExists && existsNameAlready())\n\t\t{\n\t\t\tself.text.push(\"Der angegebene Name existiert bereits, geben Sie bitte einen anderen Namen an.\");\n\t\t}\n        if(self.selectedQuery === null || self.selectedQuery === \"\"){\n            self.text.push(\"Bitte wählen Sie eine gültige Query aus.\");\n        }\n        if(!validateEmail(self.email)){\n            self.text.push(\"Bitte geben Sie eine korrekte Email Adresse ein.\");\n        }\n        if(self.type === null || self.type === \"\"){\n            self.text.push(\"Bitte geben Sie einen Datentyp ein.\");\n        }\n        if(self.filterType === null || self.filterType === \"\"){\n            self.text.push(\"Bitte geben Sie einen Filtertyp ein.\");\n        }\n        if(self.value === null || self.value === \"\"){\n            self.text.push(\"Bitte geben Sie einen gültigen Wert ein.\");\n        }\n\t}\n\t\n\t/**\n\t * Load selected alert.\n\t * \n\t * @param {Object} $query - Load this query.\n\t */\n\tself.selectLoad = function($query) {\n\t\t$requests.getQueryByName($query.query, self.getQueryByNameCB);\n\t\tself.name = $query.name;\n\t\tself.type = $query.type;\n\t\tself.filterType = $query.filterType;\n\t\tself.email = $query.email;\n\t\tself.value = $query.value;\t\t\n\t\tself.selectedAlertName = self.name;\n\t}\n\t\n\t/**\n\t * Delete selected alert.\n\t * \n\t * @param {Object} $query - Delete this query.\n\t */\n\tself.selectDelete = function($query) {\t\t\n\t\t$requests.deleteAlert($query.name, self.callback);\n\t}\n\n\t/**\n\t * Reset all values in alert form.\n\t */\n\tself.resetValues = function() {\t\t\n\t\tself.name = \"\";\n\t\tself.type = \"\";\n\t\tself.filterType = \"\";\n\t\tself.email = \"\";\n\t\tself.value = \"\";\n\t\tself.selectedQuery = \"\";\t\t\n\t\tself.selectedAlertName = \"\";\n\t}\n}]);",
    "static": true,
    "longname": "App/alerting/alerting.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1,
    "kind": "file",
    "name": "App/alertingStatistics/alertingStatistics.js",
    "content": "'use strict';\r\n\r\nangular.module('queryBuilder.alertingStatistics', ['ngRoute', 'queryBuilder.services'])\r\n\r\n.config(['$routeProvider', function($routeProvider) {\r\n  $routeProvider.when('/alertingStatistics', {\r\n    templateUrl: 'alertingStatistics/alertingStatistics.html'\r\n  });\r\n}])\r\n/**\r\n   * This controller handles the main operation in the user interface.\r\n   * It configures and handle all actions in the alert statistic view.  \r\n   * \r\n   * @version 1.0.0\r\n   */\r\n.controller('alertingStatisticsCtrl', ['$requests',\r\n\tfunction($requests) {\r\n\tvar self = this;\r\n\t\r\n    /**\r\n     * Holds selected alert name.\r\n     * @type {string}\r\n     */\r\n\tself.selectedAlert = \"\";\r\n    /**\r\n     * Stores all dates between min and max date and all counts per day from selected alert.\r\n     * @type {array}\r\n     */\r\n\tself.alertDateAndCount = [];\r\n\t/**\r\n\t * Load google charts\r\n\t */\r\n\tgoogle.charts.load('current', {packages: ['corechart', 'line']});\r\n\tgoogle.charts.setOnLoadCallback(drawBasic);\r\n\r\n\t/**\r\n\t * Draw a chart with Google charts. The chart shows how many alerts occured per day.\r\n\t * The graph shows the period from the first occurrence of an alert to the last appearance \r\n\t * of an alert.\r\n\t */\r\n\tfunction drawBasic() {\r\n\r\n\t      var data = new google.visualization.DataTable();\r\n\t      data.addColumn('date', 'Date');\r\n\t      data.addColumn('number', 'Alerts');\r\n\t      \r\n\t      var i;\r\n\t      for (i=0; i<self.alertDateAndCount.length; i++) {\r\n\t    \t  data.addRow(new Array (new Date (self.alertDateAndCount[i].date), self.alertDateAndCount[i].counts));\r\n\t      }\r\n\r\n\t      var options = {\r\n\t        hAxis: {\r\n\t          title: 'Date',\r\n\t          format: 'd/M/yy'\r\n\t        },\r\n\t        vAxis: {\r\n\t          title: 'Alerts',\r\n\t          format: '#,###',\r\n\t          minValue: 0\r\n\t        }\r\n\t      };\r\n\r\n\t      var chart = new google.visualization.LineChart(document.getElementById('chart_div'));\r\n\r\n\t      chart.draw(data, options);\r\n\t    }\r\n\t\r\n\t/**\r\n\t * Callback from get all alerts call. If query was successful show chart for first alert.\r\n\t * Otherwise print error.\r\n\t *\r\n\t * @param {boolean} $success - true when there are no errors.\r\n\t * @param {Object} $data - the requested data (In this case the alerts).\r\n     * @param {number} $status - the actual server status.\r\n\t */\r\n\tself.getAlertsCB = function($success, $data, $status) {\r\n\t\tself.hasError = !$success;\r\n\t\tif($success){\r\n\t\t\tself.existingAlerts = $data;\r\n\t\t\tif(self.existingAlerts != null && self.existingAlerts.length > 0)\r\n\t\t\t{\r\n\t\t\t\t// default selection -> first alert in array\r\n\t\t\t\tself.selectedAlert = self.existingAlerts[0].name;\r\n\t\t\t\tvar firstQuery = self.existingAlerts[0];\t\t\t\t\r\n\t\t\t\tgetDataFromAlert(firstQuery);\r\n\t\t\t}\t\t\t\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tself.error = $data;\r\n\t\t}\r\n\t}\r\n\t/**\r\n\t * When the view is called, all alerts with all data are read from graph DB once,\r\n\t * no other read tasks necessary.\r\n\t */\r\n\t$requests.getAllAlertNames(self.getAlertsCB);\r\n\r\n\t/**\r\n\t * User select another alert in comboBox.\r\n\t */\r\n\tself.selectAlert = function()\r\n\t{\r\n\t\tself.alertDateAndCount = [];\r\n\t\tvar x;\r\n\t\tvar firstQuery;\r\n\t\tfor(x=0; x<self.existingAlerts.length; x++)\r\n\t\t{\r\n\t\t\tif(self.selectedAlert == self.existingAlerts[x].name)\r\n\t\t\t{\r\n\t\t\t\tfirstQuery = self.existingAlerts[x];\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tgetDataFromAlert(firstQuery);\r\n\t}\r\n\t\r\n\t/**\r\n\t * This method evaluates the timestamp data. A two-dimensional array is generated that contains\r\n\t * all days from the first appearance of an alert to the last appearance of an alert. The number\r\n\t * of times an alert occurs per day is also counted and stored in the array.\r\n\t * \r\n     * @param {number} $selectedAlert - the alert which should be shown in chart.\r\n\t */\r\n\tfunction getDataFromAlert($selectedAlert)\r\n\t{\r\n\t\tif($selectedAlert != null)\r\n\t\t{\r\n\t\t\tvar zwischenergebnis = [];\r\n\t\t\tvar results = {}, i, date;\r\n\r\n\t\t\tvar minDate;\r\n\t\t\tvar maxDate;\r\n\t\t\t// count alerts per date, get min and max date\r\n\t\t\tfor (i=0; i<$selectedAlert.dates.length; i++) {\r\n\t\t\t  // get the date without timezone offset\r\n\t\t\t\tvar d = new Date($selectedAlert.dates[i]);\r\n\t\t\t\td = new Date(d.valueOf() + d.getTimezoneOffset() * 60000);\r\n\t\t\t  date = [d.getFullYear(),d.getMonth()+1,d.getDate()].join(\"-\");\r\n\t\t\t  results[date] = results[date] || 0;\r\n\t\t\t  results[date]++;\r\n\t\t\t  \r\n\t\t\t  if(minDate == null || minDate > date)\r\n\t\t\t  {\r\n\t\t\t\t  minDate = date;\r\n\t\t\t  }\r\n\t\t\t  if(maxDate == null || maxDate < date)\r\n\t\t\t  {\r\n\t\t\t\t  maxDate = date;\r\n\t\t\t  }\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// generate array with all values between min and max date\r\n\t\t\tvar newDates = [],\r\n\t\t    currentDate = new Date(minDate),\r\n\t\t    d;\r\n\t\t\tvar maximumDate = new Date(maxDate);\r\n\r\n\t\t\twhile (currentDate <= maximumDate) {\r\n\t\t\t    var dateFormat = currentDate.getFullYear() + '-' + (currentDate.getMonth() + 1) + '-' + currentDate.getDate();\r\n\t\t\t    \r\n\t\t\t    if(results[dateFormat] == null || results[dateFormat] == 0)\r\n\t\t    \t{\r\n\t\t\t    \tzwischenergebnis[dateFormat] = 0;\r\n\t\t    \t}\r\n\t\t\t    else\r\n\t\t    \t{\r\n\t\t\t    \tzwischenergebnis[dateFormat] = results[dateFormat];\r\n\t\t    \t}\r\n\t\t\t    \r\n\t\t\t    currentDate.setDate(currentDate.getDate() + 1);\r\n\t\t\t}\r\n\r\n\t\t\t// create a two dimensional array with date and count data\r\n\t\t\tfor (i in zwischenergebnis) {\r\n\t\t\t  if (zwischenergebnis.hasOwnProperty(i)) {\r\n\t\t\t\t  self.alertDateAndCount.push({date:i,counts:zwischenergebnis[i]});\r\n\t\t\t  }\r\n\t\t\t}\r\n\t\t\t// redraw chart\r\n\t\t\tdrawBasic();\r\n\t\t}\r\n\t}\r\n}]);",
    "static": true,
    "longname": "App/alertingStatistics/alertingStatistics.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2,
    "kind": "file",
    "name": "App/app.js",
    "content": "'use strict';\n\n// Declare app level module which depends on views, and components\nvar app = angular.module('queryBuilder', [\n  'ngRoute',\n  'ngDialog',\n  'queryBuilder.header',\n  'queryBuilder.services',\n  'queryBuilder.login',\n  'loginService',\n  'queryBuilder.expertMode',\n  'queryBuilder.register',\n  'queryBuilder.querybuilder',\n  'queryBuilder.querybuildernodedialog',\n  'queryBuilder.querybuilderrelationshipdialog',\n  'queryBuilder.querybuilderLoadDialog',\n  'queryBuilder.querybuilderInfoDialog',\n  'OutputTable',\n  'queryBuilder.alerting',\n  'queryBuilder.alertingStatistics',\n  'queryBuilder.category',\n  'queryBuilder.user',\n  'expertMode.loadDialogExpertMode'\n])\n.config(['$routeProvider', function($routeProvider) {\n  $routeProvider.when('/', {\n    templateUrl: 'login/login.html',\n    controller: 'LoginCtrl',\n        controllerAs: 'login'\n  })\n  .when('/register', {\n      templateUrl: 'register/register.html'\n  })\n  .when('/login', {\n      templateUrl: 'login/login.html'\n  })\n  .otherwise ({ redirectTo: 'login/login.html'\n  });\n}])\n\n.run(function ($rootScope, $cookies, $location) {\n  $rootScope.$on(\"$locationChangeStart\", function (event, next, current) {\n      //console.log(\"AUTH\"+$rootScope.authenticated);\n    if (!$rootScope.authenticated && ( $location.path() == \"/querybuilder\" || \n    $location.path() == \"/category\" || $location.path() == \"/alerting\" || $location.path() == \"/alertingStatistics\")) {\n      $location.path(\"/login\");\n    }\n    if (!$rootScope.admin && ($location.path() == \"/user\" )) {\n         $location.path(\"/querybuilder\");\n    }\n    if (!$rootScope.expertMode && !$rootScope.admin && ($location.path() == \"/expertmode\" )) {\n         $location.path(\"/querybuilder\");\n    }\n    if (!$rootScope.category && !$rootScope.admin && ($location.path() == \"/category\" )) {\n         $location.path(\"/querybuilder\");\n    }\n    if (!$rootScope.alert && !$rootScope.admin && ($location.path() == \"/alerting\" )) {\n         $location.path(\"/querybuilder\");\n    }\n    if (!$rootScope.alertStatistic && !$rootScope.admin &&  ($location.path() == \"/alertingStatistics\" )) {\n         $location.path(\"/querybuilder\");\n    }\n\n  });\n  /**\n   *  Holds the query of the query builder in cypher language. \n   *  @type {string}\n   */\n  $rootScope.queryBuilderQueryInCypher = undefined;\n  /**\n   *  Holds the old query of the query builder.\n   *  @type {string}\n   */\n  $rootScope.queryBuilderOldQuery = undefined;\n /**\n   *  Holds the query of the expert mode.\n   *  @type {string}\n   */\n  $rootScope.expertQuery  = undefined;\n});\n\n/**\n * This directive handles the content behind the vis.js network.\n * The options of the network, the data of the network must be\n * provided by the caller.\n * Furthermore, function can be defined which are called when \n * a user clicks a node or a edge or a user double clicks a item.\n * \n * @version 1.0.0\n */\napp.directive('visNetwork', function() {\n    return {\n        restrict: 'E',\n        require: '^ngModel',\n        scope: {\n            ngModel: '=',\n            data: '=',\n            options: '=',\n            onNodeClick: '&',\n            onEdgeClick: '&',\n            onSelectClick: '&',\n            onDoubleClick: '&'\n        },\n        link: function($scope, $element, $attrs, ngModel) {\n            var $network = new vis.Network($element[0], $scope.data || \n                  {nodes: undefined,\n                    edges: undefined}, $scope.options || {});\n            $scope.ngModel = $network;\n\n            var onNodeClick = $scope.onNodeClick || function(prop) {};\n            var onEdgeClick = $scope.onEdgeClick || function(prop) {};\n            var onSelectClick = $scope.onSelectClick || function(prop) {};\n            var onDoubleClick = $scope.onDoubleClick || function(prop) {};\n \n            $network.on('selectNode', function (params)  {\n                onNodeClick({params: params, network: $network});\n            });\n\n            $network.on('selectEdge', function(params) {\n                onEdgeClick({params: params, network: $network});\n            });\n            \n            $network.on('select', function(params) {\n                onSelectClick({params: params, network: $network});\n            });\n\n            $network.on('doubleClick', function(params) {\n                onDoubleClick({params: params, network: $network});\n            });\n        }\n    }\n});\n\n/**\n *\n * With this directive one can watch not only the changes of the model\n * but also the changes within a certain model (subproberty of the model).\n * If there was a change the visualisation will be updated.\n *\n * @version 1.0.0\n */\napp.directive('ngWatch', function() {\n    return {\n        restrict: 'A',\n        require: 'ngModel',\n        scope: {\n            ngModel: '=', \n            ngWatch: '=', /* whatches an object for change*/\n\n            ngWatchObjectValue: \"@\" /* set changed value to model*/\n        },\n        link: function($scope, $element, $attrs, ngModel) {\n\n            $scope.$watch('ngWatch', function(newValue, oldValue) {\n                if (newValue){\n                  if($scope.ngWatchObjectValue){\n                    ngModel.$setViewValue(newValue[$scope.ngWatchObjectValue]);\n                  }\n                  else{\n                    ngModel.$setViewValue(newValue);\n                  }\n                  ngModel.$render();\n                }      \n            }, true);\n        }\n    }\n});\n\n",
    "static": true,
    "longname": "App/app.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 3,
    "kind": "variable",
    "name": "app",
    "memberof": "App/app.js",
    "static": true,
    "longname": "App/app.js~app",
    "access": null,
    "export": false,
    "importPath": "./App/app.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 4,
    "kind": "file",
    "name": "App/category/category.js",
    "content": "'use strict';\r\n\r\nangular.module('queryBuilder.category', ['ngRoute', 'queryBuilder.services'])\r\n\r\n.config(['$routeProvider', function($routeProvider) {\r\n  $routeProvider.when('/category', {\r\n    templateUrl: 'category/category.html'\r\n  });\r\n}])\r\n.controller('categoryCtrl', ['$requests',\r\n\tfunction($requests) {\r\n\tvar self = this;\r\n\t\r\n\r\n\t/**\r\n     * Holds name from category.\r\n     * @type {string}\r\n     */\r\n\tself.name = \"\";\r\n\t/**\r\n     * Holds description from category.\r\n     * @type {string}\r\n     */\r\n\tself.description = \"\";\t\r\n\t/**\r\n     * Holds id from category.\r\n     * @type {string}\r\n     */\r\n  \tself.id = \"\";\r\n\t  /**\r\n     * Store all categories which exists.\r\n     * @type {array}\r\n     */\r\n \t self.existingCategories = [];\r\n\t\r\n\t/**\r\n\t * Modal dialog for missing or invalid data.\r\n     * @type {object}\r\n\t */\r\n\tvar missingDataModal = document.getElementById('myModalMissingData');\r\n\t/**\r\n\t * Ok-button from modal dialog for missing or invalid data.\r\n     * @type {object}\r\n\t */\r\n\tvar missingDataOkButton = document.getElementById(\"missingDataOk\");\r\n\t\r\n\t/**\r\n\t * Close modal dialog if user select the ok-button in dialog.\r\n\t */\r\n\tmissingDataOkButton.onclick = function() {\r\n\t\tmissingDataModal.style.display = \"none\";\r\n\t}\r\n\t\r\n\t/**\r\n     * Holds the error string which is displayed to the user.\r\n     * The table is only shown when the hasError property is set to TRUE.\r\n     * @type {string}\r\n     */\r\n\tself.error = \"\";\r\n\t /**\r\n     * If there was an error during the execution of the query this is set to \r\n     * true and the error will be displayed. Otherwise the table will be displayed.\r\n     * @type {boolean}\r\n     */\r\n\tself.hasError = false;\r\n\t\r\n\t/**\r\n\t * Callback from delete/save category call. If query was successful refresh category names.\r\n\t * Otherwise print error.\r\n\t *\r\n\t * @param {boolean} $success - true when there are no errors.\r\n\t * @param {Object} $data - the requested data.\r\n     * @param {number} $status - the actual server status.\r\n\t */\r\n\tself.callback = function($success, $data, $status) {\r\n\t\tself.hasError = !$success;\r\n\t\tif($success){\r\n\t\t\t// self.existingCategories = $data;\r\n\t\t\t$requests.getAllCategories(self.getCategories);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tself.error = $data;\r\n\t\t}\r\n\t}\r\n\t\r\n\t /**\r\n\t * Callback from get all categories call. If query was successful save data in variable self.existingCategories.\r\n\t * Otherwise print error.\r\n\t * \r\n\t * @param {boolean} $success - true when there are no errors.\r\n\t * @param {Object} $data - the requested data (In this case the categories).\r\n     * @param {number} $status - the actual server status.\r\n\t */\r\n\tself.getCategories = function($success, $data, $status) {\r\n\t\tself.hasError = !$success;\r\n\t\tif($success){\r\n\t\t\tself.existingCategories = $data;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tself.error = $data;\r\n\t\t}\r\n\t}\t\r\n\t$requests.getAllCategories(self.getCategories);\r\n\t\r\n\t/**\r\n\t * Create new category, if all fields are filled correctly.\r\n\t */\r\n    self.addCategory = function (ev) {\r\n    \tcheckAllFieldsValidate(true);\r\n        if(self.text != \"\"){\r\n            missingDataModal.style.display = \"block\";\r\n        }\r\n        else\r\n\t\t{\r\n            $requests.addCategory(self.name, self.description, self.callback);\r\n        }\r\n    };\r\n    \r\n\t/**\r\n\t * Updates already existing category, if all fields are filled correctly.\r\n\t */\r\n    self.updateCategory = function (ev) {\r\n    \tcheckAllFieldsValidate(false);\r\n        if(self.text != \"\"){\r\n            missingDataModal.style.display = \"block\";\r\n        }\r\n        else\r\n\t\t{\r\n\t\t\t$requests.updateCategory(self.id, self.name, self.description, self.callback);\r\n        }\r\n    };\r\n\t\r\n\r\n\t/**\r\n\t * Check if the name from category form already exists.\r\n\t */\r\n\tfunction existsNameAlready() {\r\n\t\t$requests.getAllCategories(self.getCategories);\r\n\r\n\t\tfor (var i = 0; i < self.existingCategories.length; i++)\r\n\t    {\r\n\t        if (self.existingCategories[i].name === self.name)\r\n\t        {\r\n\t            return true;\r\n\t        }\r\n\t    }\r\n\t    return false;\r\n\t\t\r\n\t}\r\n\t\r\n\t/**\r\n\t * Check if all fields in category form are correctly filled.\r\n\t * \r\n\t * @param {boolean} $checkIfNameExists - Is it necessary to check the name.\r\n\t */\r\n\tfunction checkAllFieldsValidate($checkIfNameExists) {\r\n    \tself.text = [];\r\n\t\tif($checkIfNameExists && (self.name === null || self.name === \"\"))\r\n\t\t{\r\n            self.text.push(\"Bitte geben Sie einen Namen ein.\");\r\n        }\r\n\t\telse if($checkIfNameExists && existsNameAlready())\r\n\t\t{\r\n\t\t\tself.text.push(\"Der angegebene Name existiert bereits, geben Sie bitte einen anderen Namen an.\");\r\n\t\t}\r\n        \r\n\t}\r\n\t\r\n\r\n\t/**\r\n\t * Load selected category.\r\n\t * \r\n\t * @param {Object} $query - Load this query.\r\n\t */\r\n\tself.selectLoad = function($query) {\t\t\r\n\t\tself.name = $query.name;\r\n\t\tself.description = $query.description;\r\n    \tself.id = $query.id;\t\t\r\n\t\tself.selectedAlertName = self.name;\r\n\t}\r\n\t\r\n\t\t/**\r\n\t * Delete selected category.\r\n\t * \r\n\t * @param {Object} $query - Delete this query.\r\n\t */\r\n\tself.selectDelete = function($query) {\t\t\r\n\t\t$requests.deleteCategory($query.id, self.callback);\r\n\t}\r\n\t\r\n}]);",
    "static": true,
    "longname": "App/category/category.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 5,
    "kind": "file",
    "name": "App/expertMode/expertMode.js",
    "content": "'use strict';\n\nangular.module('queryBuilder.expertMode', ['ngRoute', 'queryBuilder.services'])\n\n.config(['$routeProvider', function($routeProvider) {\n  $routeProvider.when('/expertmode', {\n    templateUrl: 'expertMode/expertMode.html'\n  });\n}])\n/**\n   * This controller handles the main operation in the user interface.\n   * It configures and handle all actions in the expert mode.\n   * \n   * @version 1.0.0\n   */\n.controller('expertModeCtrl', ['$requests','$rootScope', 'ngDialog',\n\tfunction($requests, $rootScope, ngDialog) {\n\n    var self = this;\n    \n    /**\n     * Uses a \"CodeMirror\" textArea with syntax highlighting.\n     * For further information about CodeMirror look at\n     * https://codemirror.net/\n     */\n    self.myCodeMirror = CodeMirror.fromTextArea(document.getElementById('query'), {\n        mode: 'cypher',\n        indentWithTabs: true,\n        smartIndent: true,\n        lineNumbers: true,\n        matchBrackets : true,\n        autofocus: true,\n        theme: 'neo',\n        viewportMargin: Infinity\n      });\n    \n    self.query = \"\";\n    /**\n     * Store the parameter from selected query in this array.\n     * @type {array}\n     */\n\tself.params = [];\n    /**\n     * If a value from expert query is missing or invalid in save dialog\n     * a message will be stored in this array.\n     * @type {array}\n     */\n\tself.invalidSaveText = [];\n\t\n\t/**\n\t * Whenever the query changes, the parameters should be adjusted automatically.\n\t * Parameters are currently recognized by \"{\".\n\t * \n\t * @param {Object} cMirror - is the \"CodeMirror\" textarea from view.\n\t */\n    self.myCodeMirror.on('change',function(cMirror){\n    \t\tself.query = cMirror.getValue();\n    \t\t$rootScope.expertQuery = query;\n    \t\tvar paramcnt = self.query.split(\"{\").length - 1;\n    \t\tvar keys = '';\n    \t\tvar startIndex = 0;\n    \t\tvar endIndex = 0;\n    \t\t\n    \t\t// Removing and regenerating parameters\n    \t\tself.params = [];\n    \t\t\n    \t\t/**\n    \t\t * The first parameter is read out because a parameter could already \n    \t\t * be present at position 0, although this will not be a correct \n    \t\t * statement ...\n    \t\t */\n    \t\tstartIndex = self.query.indexOf(\"{\", startIndex);\n    \t\tendIndex = self.query.indexOf(\"}\", startIndex);\n    \t\tkeys = self.query.substring(startIndex+1, endIndex);\n    \t\t    \t\t\n    \t\tvar i;\n    \t\tfor(i = 0; self.params.length < paramcnt; i++)\n    \t\t{\n    \t\t\tself.params.push.apply(self.params, [{key: keys, type : \"int\", value : \"\"}]);\n        \t\tstartIndex = self.query.indexOf(\"{\", startIndex+1);\n        \t\tendIndex = self.query.indexOf(\"}\", startIndex+1);\n        \t\tkeys = self.query.substring(startIndex+1, endIndex);\n    \t\t}\n        \t$rootScope.$apply();\n    \t});\n    \t\n    /**\n     * Selectable parameter types.\n     */\n\tself.paramoptions = [\"int\", \"String\", \"double\", \"long\", \"boolean\"];\n\t/** \n\t * The following three variables are query fields in save dialog.\n\t */\n\tself.name = \"\";\n\tself.description = \"\";\n\tself.category = \"\";\n\n\t//sets actual query from expert mode\n\tif(\t$rootScope.expertQuery !== undefined){\n\t\tself.myCodeMirror.setValue($rootScope.expertQuery);\n\t}\n\t//set query from querybuilder to expertmode\n\telse if($rootScope.queryBuilderQueryInCypher !== undefined){\n\t\tself.myCodeMirror.setValue($rootScope.queryBuilderQueryInCypher );\n\t}\n\n\t/** \n\t\tTable json (simply the result)\n\t*/\n\tself.table = \"\";\n\t /**\n     * Holds the error string which is displayed to the user.\n     * The table is only shown when the hasError property is set to TRUE.\n     * @type {string}\n     */\n\tself.error = \"\";\n\t /**\n     * If there was an error during the execution of the query this is set to \n     * true and the error will be displayed. Otherwise the table will be displayed.\n     * @type {boolean}\n     */\n\tself.hasError = false;\t\n\t/**\n\t * All existing queries. This queries will be shown in load/delete dialog.\n     * @type {array}\n\t */\n\tself.queries = [];\n\t/**\n\t * Modal dialog for saving queries.\n     * @type {object}\n\t */\n\tvar modalSave = document.getElementById('myModalSave');\t\n\t/**\n\t * Save button which opens save modal dialog.\n     * @type {object} \n\t */\n\tvar btnSave = document.getElementById(\"saveQuery\");\n\t/**\n\t * Load button which opens load/delete ngDialog.\n     * @type {object} \n\t */\n\tvar btnLoad = document.getElementById(\"loadQuery\");\n\t/**\n\t * Delete button which opens load/delete ngDialog.\n     * @type {object} \n\t */\n\tvar btnDelete = document.getElementById(\"deleteQuery\");\n\t/**\n\t * cancel-button from modal dialog for missing or invalid data.\n     * @type {object}\n\t */\n\tvar saveAbbruch = document.getElementById(\"saveAbbruch\");\n\n\t/**\n\t * When the user clicks on the button, open the modal dialog\n\t * for saving queries.\n\t */\n\tbtnSave.onclick = function() {\n\t\tself.invalidSaveText = [];\n\t\tmodalSave.style.display = \"block\";\n\t\t\n\t}\n\t/**\n\t * When the user clicks on the button, open the ngDialog\n\t * for loading/deleting queries.\n\t */\n\tbtnLoad.onclick = function() {\n\t\t$requests.loadAllQueries(self.queriesCB);\n\t\t\n\t\tvar dialog = ngDialog.open({ template: 'expertMode/loadDialogExpertMode.html',\n\t\t\tclassName: 'ngdialog-theme-default custom-width',\n\t\t\tcontroller: 'loadDialogExpertModeCtrl',\n\t\t\tcontrollerAs: 'ctrl'});\n\t\t\n\t\t/**\n\t\t * Close ngDialog is only possible if user select a load button or\n\t\t * select close button. Check if user has select the load button.\n\t\t */\n\t\tdialog.closePromise.then(function ($data) {\n        \tif($data !== undefined && $data.value !== undefined &&\n        \t\t\t$data.value.query !== undefined)\n        \t{\n        \t\tself.select($data.value);\n        \t}\n\t\t});\n\t}\n\t/**\n\t * When the user clicks on the button, open the ngDialog\n\t * for loading/deleting queries.\n\t */\t\n\tbtnDelete.onclick = function() {\n\t\t$requests.loadAllQueries(self.queriesCB);\n\t\t\n\t\tvar dialog = ngDialog.open({ template: 'expertMode/loadDialogExpertMode.html',\n\t\t\tclassName: 'ngdialog-theme-default custom-width',\n\t\t\tcontroller: 'loadDialogExpertModeCtrl',\n\t\t\tcontrollerAs: 'ctrl'});\n\t\t\n\t\t/**\n\t\t * Close ngDialog is only possible if user select a load button or\n\t\t * select close button. Check if user has select the load button.\n\t\t */\n\t\tdialog.closePromise.then(function ($data) {\n        \tif($data !== undefined && $data.value !== undefined &&\n        \t\t\t$data.value.query !== undefined)\n        \t{\n        \t\tself.select($data.value);\n        \t}\n\t\t});\n\t}\n\n\t/**\n\t * User has cancelled the save dialog. Reset values, otherwise they will be \n\t * displayed again by in next save dialog.\n\t */\n\tsaveAbbruch.onclick = function() {\n\t\tself.name = \"\";\n\t\tself.description = \"\";\n\t\tself.category = \"\";\n\t\t// close save dialog\n\t\tmodalSave.style.display = \"none\";\n\t}\n\n\t/**\n\t * Callback from execute, delete and save query. If query was successful show result in table.\n\t * Otherwise print error.\n\t * \n\t * @param {boolean} $success - true when there are no errors.\n\t * @param {Object} $data - the requested data.\n     * @param {number} $status - the actual server status.\n\t */\n\tself.callback = function($success, $data, $status) {\n\t\tself.hasError = !$success;\n\t\tif($success){\n\t\t\tself.table = $data;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tself.error = $data;\n\t\t}\n\t}\n\t\n\t/**\n\t * Callback from get all queries call. If query was successful save data in variable self.queries.\n\t * Otherwise print error.\n\t * \n\t * @param {boolean} $success - true when there are no errors.\n\t * @param {Object} $data - the requested data (In this case the queries).\n     * @param {number} $status - the actual server status.\n\t */\n\tself.queriesCB = function($success, $data, $status){\n\t\tself.hasError = !$success;\n\t\tif($success)\n\t\t{\n\t\t\tself.queries = $data;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tself.error = $data;\n\t\t}\n\t}\n\n\t/**\n\t * Execute actual query.\n\t */\n\tself.submitQuery = function() {\n\t\t$requests.getResultFromQuery(self.myCodeMirror.getValue(), self.params, self.callback);\n\t}\n\t\n\t/**\n\t * Save actual query if all fields in save dialog were filled correctly and query name\n\t * do not exists until now.\n\t */\n\tself.saveQuery = function()\n\t{\n\t\tself.invalidSaveText = [];\n\t\tvar queryName = self.name;\n\t\t$requests.loadAllQueries(self.queriesCB);\n\t\t\n\t\tif(!existsQueryName(queryName))\n\t\t{\n\t\t\tconsole.log(self.categoryName);\n\t\t\tself.invalidSaveText = [];\n\t\t\t$requests.saveQuery(self.myCodeMirror.getValue(), self.params, \n\t\t\t\t\tqueryName, self.description, self.categoryName, self.callback);\n\t\t\t// Reset values, otherwise they will be displayed again by in next save dialog.\n\t\t\tself.name = \"\";\n\t\t\tself.description = \"\";\n\t\t\tself.category = \"\";\n\t\t\t// Close save dialog\n\t\t\tmodalSave.style.display = \"none\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tself.invalidSaveText.push(\"Der Queryname existiert bereits, \" +\n\t\t\t\t\t\"verwenden Sie bitte einen anderen Querynamen.\");\n\t\t}\n\t}\n\t\n\t/**\n\t * Delete actual query.\n\t */\n\tself.deleteSelectedQuery = function($query)\n\t{\n\t\t$requests.deleteQuery($query.query, $query.parameter, \n\t\t\t\t$query.name, $query.description, $query.category, self.callback);\n\t}\n\t\n\t/**\n\t * Load selected query.\n\t * \n\t * @param {Object} $query - query which should be load.\n\t */\n\tself.select = function($query) {\t\t\n\t\tself.myCodeMirror.setValue($query.query);\n\t\t\n\t\tself.params = [];\n\t\tvar arrLength = $query.parameter.length;\n\t\tvar i;\n\t\tfor(i = 0; self.params.length < arrLength; i++)\n\t\t{\n    \t\tself.params.push.apply(self.params, [{key: $query.parameter[i].key, type : $query.parameter[i].type,\n    \t\t\tvalue : $query.parameter[i].value}]);\n\t\t}\n\t}\n\t\n\t/**\n\t * Check if the queryName already exists.\n\t * \n\t * @param {Object} $$queryName - query name which should be checked.\n\t */\n\tfunction existsQueryName($queryName)\n\t{\n\t    for (var i = 0; i < self.queries.length; i++)\n\t    {\n\t        if (self.queries[i].name === $queryName)\n\t        {\n\t            return true;\n\t        }\n\t    }\n\t    return false;\n\t}\n\n\t/**\n\t * Stores all available categories.\n     * @type {array} \n\t */\n\tself.availableCategories = [];\n\t/**\n\t * Actual selected category name.\n     * @type {string} \n\t */\n\tself.categoryName = \"\";\n\n\n\t/**\n\t * Callback from get all categories. If query was successful save data in variable self.availableCategories.\n\t * The categories are displayed in the save dialog and in the load/delete dialog.\n\t * Otherwise print error.\n\t * \n\t * @param {boolean} $success - true when there are no errors.\n\t * @param {Object} $data - the requested data (In this case the categories).\n     * @param {number} $status - the actual server status.\n\t */\n\tself.getCategories = function($success, $data, $status){\n\t\tself.hasError = !$success;\n\t\tif($success){\n\t\t\tself.availableCategories = $data;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tself.error = $data;\n\t\t}\n\t}\n\t$requests.getAllCategories(self.getCategories);\n}]);",
    "static": true,
    "longname": "App/expertMode/expertMode.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 6,
    "kind": "file",
    "name": "App/expertMode/loadDialogExpertMode.js",
    "content": "'use strict';\n\nangular.module('expertMode.loadDialogExpertMode', ['ngRoute'])\n\n/**\n * This controller is in charge of loading, filtering and deleting queries.\n * @version 1.0.0\n */\n.controller('loadDialogExpertModeCtrl', ['$requests', '$scope', \n    function($requests, $scope) {\n    var self = this;\n\n    /**\n     * The entered category for querying the results.\n     * @type {string}\n     */\n    self.category = undefined;\n    /**\n     * The entered name for querying the results.\n     * @type {string} \n     */\n    self.name = undefined;\n    /**\n     * The description category for querying the results.\n     * @type {string}\n     */\n    self.description = undefined;\n    /**\n     * The loaded querys.\n     * @type {string}\n     */\n    self.loadedQueries = [ ];\n    /**\n     * The available categories.\n     * @type {array}\n     */\n    self.availableCategories = [];\n\n    /**\n     * The callback when all queries were loaded.\n     *\n     * @param {boolean} $success - true when there are no errors.\n     * @param {json} $data - the requested data (In this case the queries).\n     * @param {number} $status - the actual server status.\n     */\n    self.loadQueriesInBuilderCB = function($success, $data, $status){\n        if($success){\n            self.loadedQueries = $data;\n        }\n    }\n\n    $requests.loadAllQueries( self.loadQueriesInBuilderCB);\n\n    /**\n     * This method closes this dialog and delivers the query.\n     *\n     * @param {string} $query - delivers the selected query.\n     */\n    self.selectQuery = function($query){    \t\t\n         $scope.closeThisDialog($query);\n    };\n\n    /**\n     * The callback when the requested query was deleted.\n     *\n     * @param {boolean} $success - true when there are no errors.\n     * @param {json} $data - the requested data (In this case no data will be sent).\n    * @param {number} $status - the actual server status.\n     */\n    self.deleteQueryCallback = function($success, $data, $status) {\n        if($success){\n        \t$requests.loadAllQueries(self.loadQueriesInBuilderCB);\n        }\n        \n    }\n\n    /**\n     * This method deletes a query.\n     *\n     * @param {id} $id - the id of the query which should be deleted.\n     */\n    self.deleteSelectedQuery = function($query){\n\t\t$requests.deleteQuery($query.query, $query.parameter, \n\t\t\t\t$query.name, $query.description, $query.category, self.deleteQueryCallback);\n    }\n\n    /**\n     * This method applies a filter.\n     * It uses the input data name, category and description to apply the filter.\n     *\n     */\n    self.applyFilter = function() {\n        $requests.loadSomeQueriesInExpertMode(self.loadQueriesInBuilderCB, self.name, self.category, self.description);\n     }\t\n\n   /**\n     * The callback when the requested categories were loaded\n     *\n     * @param {boolean} $success - true when there are no errors.\n     * @param {json} $data - the requested data (In this case the categories).\n     * @param {number} $status - the actual server status.\n     */\n    self.getCategoriesCallBack = function($success, $data, $status){\n        self.hasError = !$success;\n        if($success){\n\n            self.availableCategories = $data;\n        }\n        else\n        {\n            self.error = $data;\n        }\n    }\n\n    $requests.getAllCategories(self.getCategoriesCallBack);\n\n}]);\n",
    "static": true,
    "longname": "App/expertMode/loadDialogExpertMode.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 7,
    "kind": "file",
    "name": "App/login/login.js",
    "content": "'use strict';\r\n\r\nangular.module('queryBuilder.login', [])\r\n  .controller('LoginCtrl', function ($rootScope, $scope, $location, $cookies, loginservice) {\r\n\r\n    var self = this;\r\n\r\n    /**\r\n     * Stores typed-in username.\r\n     * @type {string}\r\n     */\r\n    $scope.username;\r\n    /**\r\n     * Stores typed-in password.\r\n     * @type {string}\r\n     */\r\n    $scope.password;\r\n    /**\r\n     * Holds if a user is already logged in.\r\n     * @type {string}\r\n     */\r\n    self.loggedin = $rootScope.authenticated;\r\n\r\n    /**\r\n\t  * Executes the login of the user with the typed in username and password\r\n\t  */\r\n    $rootScope.execlogin = function () {\r\n\r\n      loginservice.login(self.username, self.password).then(function () {\r\n        updateAuthStatus();\r\n      }, function () {\r\n        $(\"#loginErrorModal\").modal();\r\n      });\r\n    };\r\n    \r\n    /**\r\n\t  * Executes the logout of the actually logged in user\r\n\t  */\r\n    $rootScope.execlogout = function () {\r\n\r\n      loginservice.logout();\r\n      $rootScope.admin = false;\r\n      $rootScope.expertMode = false;\r\n      $rootScope.category = false;\r\n      $rootScope.alert = false;\r\n      $rootScope.alertStatistic = false;\r\n      updateAuthStatus();\r\n      $location.path(\"/\");\r\n      $rootScope.$broadcast('login');\r\n    };\r\n\r\n    /**\r\n\t  * Updates the Authorization and Authentication status of the application, depending on the logged in user\r\n\t  */\r\n    var updateAuthStatus = function () {\r\n      var authenticated = false;\r\n      if (loginservice.principal && loginservice.authorities) {\r\n        var i = 0;\r\n        while (!false && i < loginservice.authorities.length) {\r\n          \r\n          if (loginservice.authorities[i].authority == \"ROLE_USER\") {\r\n            authenticated = true;\r\n          }\r\n           if (loginservice.authorities[i].authority == \"ROLE_ADMIN\") {\r\n             $rootScope.admin = true;\r\n            authenticated = true;\r\n          }\r\n           if (loginservice.authorities[i].authority == \"EXPERTMODE\") {\r\n             $rootScope.expertMode = true;\r\n          }\r\n          if (loginservice.authorities[i].authority == \"CATEGORY\") {\r\n             $rootScope.category = true;\r\n          }\r\n          if (loginservice.authorities[i].authority == \"ALERT\") {\r\n             $rootScope.alert = true;\r\n          }\r\n          if (loginservice.authorities[i].authority == \"ALERTSTATISTIC\") {\r\n             $rootScope.alertStatistic = true;\r\n          }\r\n          i++;\r\n        }\r\n      }\r\n      $rootScope.authenticated = authenticated;\r\n      $rootScope.principal = loginservice.principal;\r\n\r\n      /**\r\n\t    * Broadcasts the authentication change for other functions controllers\r\n\t    */\r\n      $rootScope.$broadcast('authenticationChanged');\r\n      if ($rootScope.authenticated) {\r\n        $rootScope.$broadcast('login');\r\n        $location.path(\"/querybuilder\");\r\n      } else {\r\n        $location.path(\"/login\");\r\n      }\r\n    };\r\n\r\n\r\n  });\r\n\r\n",
    "static": true,
    "longname": "App/login/login.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 8,
    "kind": "file",
    "name": "App/loginService.js",
    "content": "'use strict';\r\n\r\nangular.module('loginService', [])\r\n  .factory('loginservice', function ($http, $q, $serverRestLocation) {\r\n\r\n    var service = {};\r\n\r\n    /**\r\n\t  * Service to login a user. Sends a authorization request to the server and if successful add the authorization cookie to the default header\r\n\t  * \r\n\t  * @param {String} $username - username of the user which should be logged in.\r\n    * @param {String} $password - password of the user which should be logged in.\r\n\t  */\r\n    service.login = function (username, password) {\r\n      $http.defaults.headers.common['Authorization'] = null;\r\n\r\n      var url = $serverRestLocation.getValue()+'/authentications/user';\r\n      var headers = username && password ? {\r\n        'Authorization': \"Basic \" + btoa(username + \":\" + password)\r\n      } : {};\r\n\r\n\r\n      var deferred = $q.defer();\r\n      $http.get(url, { headers: headers }).success(function (user) {\r\n        if (user.authenticated) {\r\n          service.authenticated = true;\r\n          service.principal = user.principal;\r\n          service.authorities = user.authorities;\r\n          $http.defaults.headers.common['Authorization'] = \"Basic \" + btoa(username + \":\" + password);\r\n          deferred.resolve();\r\n        } else {\r\n          clearAuth();\r\n          deferred.reject();\r\n        }\r\n      }).error(function () {\r\n        clearAuth();\r\n        deferred.reject();\r\n      });\r\n\r\n      return deferred.promise;\r\n    };\r\n\r\n    /**\r\n\t  * Service to logout a user. Deletes the default authorization cookie and clears all Authorization\r\n\t  * \r\n\t  */\r\n    service.logout = function () {\r\n      $http.defaults.headers.common['Authorization'] = null;\r\n      clearAuth();\r\n    \r\n      var deferred = $q.defer();\r\n    };\r\n\r\n    /**\r\n\t  * Function to clear all saved authorization states.\r\n\t  * \r\n\t  */\r\n    var clearAuth = function () {\r\n      service.authenticated = false;\r\n      service.principal = null;\r\n      service.authorities = null;\r\n    };\r\n\r\n    clearAuth();\r\n\r\n    return service;\r\n  });\r\n",
    "static": true,
    "longname": "App/loginService.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 9,
    "kind": "file",
    "name": "App/menu/header.js",
    "content": "'use strict';\n\nangular.module('queryBuilder.header',[])\n.controller('headerCtrl',  function($rootScope, $scope){\n\t\n\tvar self = this;\n\n\t/**\n     * Stores the authentication status.\n     * @type {boolean}\n     */\n\tself.loggedin = $rootScope.authenticated;\n\n\t/**\n     * Stores the different header items.\n     * @type {array}\n     */\n\t $scope.items = [\n\t\t{'name': 'Query Builder', 'link' : 'querybuilder', \"needAuthentication\": true},\n\t\t{'name': 'Expertmode', 'link' : 'expertmode', \"needAuthentication\": true},\n\t\t{'name': 'Category', 'link' : 'category', \"needAuthentication\": true},\t\n\t\t{'name': 'Alerting', 'link' : 'alerting', \"needAuthentication\": true},\n\t\t{'name': 'Alert statistics', 'link' : 'alertingStatistics', \"needAuthentication\": true},\n        {'name': 'Register', 'link' : 'register', \"needAuthentication\": false},\n        {'name': 'Login', 'link' : 'login', \"needAuthentication\": false},\n\t\t{'name': 'Logout', 'link' : 'login', \"needAuthentication\": true},\n\t\t{'name': 'User', 'link' : 'user', \"needAuthentication\": true}    \n    ];\n\n\t/**\n     * Listens to the login broadcast, if authentication changes the header is changed.\n     */\n\t$scope.$on('login', function () {\t\n\tself.loggedin = $rootScope.authenticated;\n    });\n\n\t/**\n\t * Checks if a specific header item should be shown or not.\n\t * \n\t * @param {String} item - Name of the item which should be checked.\n\t */\n\n\t$scope.condition = function(item) { \n\t\tif( item.name == \"User\") {\n\t\t\treturn $rootScope.admin\n\t\t}\n\t\tif( item.name == \"Expertmode\") {\n\t\t\treturn $rootScope.expertMode || $rootScope.admin\n\t\t}\n\t\tif( item.name == \"Category\") {\n\t\t\treturn $rootScope.category || $rootScope.admin\n\t\t}\n\t\tif( item.name == \"Alerting\") {\n\t\t\treturn $rootScope.alert || $rootScope.admin\n\t\t}\n\t\tif( item.name == \"Alert statistics\") {\n\t\t\treturn $rootScope.alertStatistic || $rootScope.admin\n\t\t}\n\t\t\n\t\tif( item.name == \"Login\") {\n\t\t\treturn !self.loggedin\n\t\t} else {\n\t\treturn (item.needAuthentication == false || (item.needAuthentication == true && self.loggedin)); };\n\t}\n\n});\n",
    "static": true,
    "longname": "App/menu/header.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 10,
    "kind": "file",
    "name": "App/outputTable.js",
    "content": "(function(angular) {\r\n  'use strict';\r\nangular.module('OutputTable', [])\r\n  .controller('Controller', ['$scope', function($scope) {\r\n\r\n    /**\r\n\t  * Function for changing the data from which the table should be built.\r\n\t  * \r\n    * @param {Object} $data - Data from which the ouptput table should be built.\r\n\t  */\r\n    $scope.setData = function (data) {\r\n        $scope.input = data;\r\n        $scope.data = convertTableWidgetData(data);\r\n    }\r\n\r\n    /**\r\n\t  * Function for converting the Data from the database to a table.\r\n\t  * \r\n    * @param {Object} $widgetData - Data from which the ouptput table should be built.\r\n\t  */                \r\n    function convertTableWidgetData(widgetData) {\r\n      var headerData = getTableHeader(widgetData);\r\n      var bodyData = getTableBody(widgetData);\r\n      return {tableHeader:headerData, tableBody:bodyData};\r\n    }\r\n\r\n    /**\r\n\t  * Function creating the header of the table.\r\n\t  * \r\n    * @param {Object} $widgetData - Data from which the ouptput table should be built.\r\n\t  */  \r\n    function getTableHeader(data){\r\n      var headerData = convertTableHeader(data[0], 1);\r\n      var maxLevel = 0;\r\n      for(var i=0;i<headerData.length;i++){\r\n        if(headerData[i].level>maxLevel){\r\n          maxLevel = headerData[i].level;\r\n        }\r\n      }\r\n      var tableColumns = [];\r\n      for (var level = 1; level <= maxLevel; level++) {\r\n        var headerRow = [];\r\n        for (var i = 0; i < headerData.length; i++) {\r\n          if (headerData[i].level == level) {\r\n            var rowSpan = 1;\r\n            if (headerData[i].elementType == \"primitive\") {\r\n              rowSpan = maxLevel - headerData[i].level + 1;\r\n            }\r\n            headerRow.push({title: headerData[i].title,colspan:headerData[i].colspan,rowspan:rowSpan});\r\n          }\r\n        }\r\n        tableColumns.push(headerRow);\r\n      }\r\n      return tableColumns;\r\n    }\r\n\r\n    /**\r\n\t  * Function for converting the data to headings for the output table.\r\n\t  * \r\n    * @param {Object} $data - Data from which the ouptput table should be built.\r\n    * @param {Object} $level - Level of the table in which the heading should be.\r\n\t  */      \r\n    function convertTableHeader(data, level) {\r\n      var headerData = [];\r\n      for (var prop in data) {\r\n        if (typeof data[prop] == 'object' && data[prop] != null) {\r\n          var subHeaderData = convertTableHeader(data[prop], level + 1);                \r\n          var colspan = 0;\r\n          for(var i=0;i<subHeaderData.length;i++){\r\n            colspan += subHeaderData[i].colspan;\r\n            headerData.push(subHeaderData[i]);\r\n          }\r\n          headerData.push({ title: prop, level: level, colspan: colspan, elementType: \"object\"});\r\n        }\r\n        else{\r\n          headerData.push({ title: prop, level: level, colspan: 1, elementType: \"primitive\"});\r\n        }\r\n      }\r\n      return headerData;\r\n    }\r\n\r\n    /**\r\n\t  * Function creating the body of the table.\r\n\t  * \r\n    * @param {Object} $widgetData - Data from which the ouptput table should be built.\r\n\t  */  \r\n    function getTableBody(data){\r\n      var tableRows = [];\r\n      for(var j = 0;j < data.length; j++){\r\n        var bodyData = convertTableBody(data[j], 1);\r\n        var maxLevel = 0;\r\n        for(var i=0;i<bodyData.length;i++){\r\n          if(bodyData[i].level>maxLevel){\r\n            maxLevel = bodyData[i].level;\r\n          }\r\n        }\r\n        for (var level = 1; level <= maxLevel; level++) {\r\n          var row = [];\r\n          for (var i = 0; i < bodyData.length; i++) {\r\n            if (bodyData[i].level == level) {\r\n              var rowSpan = 1;\r\n              if (bodyData[i].elementType == \"primitive\") {\r\n                rowSpan = maxLevel - bodyData[i].level + 1;\r\n              }\r\n              row.push({title: bodyData[i].title,colspan:bodyData[i].colspan,rowspan:rowSpan});\r\n            }\r\n          }\r\n          tableRows.push(row);\r\n        }\r\n      }\r\n      return tableRows;\r\n    }\r\n\r\n    /**\r\n\t  * Function for converting the data to body rows and columns for the output table.\r\n\t  * \r\n    * @param {Object} $data - Data from which the ouptput table should be built.\r\n    * @param {Object} $level - Level of the table in which the body data should be.\r\n\t  */\r\n    function convertTableBody(data, level) {\r\n      var bodyData = [];\r\n      for (var prop in data) {\r\n        if (typeof data[prop] == \"object\" && data[prop] != null) {\r\n          var subBodyData;\r\n            subBodyData = convertTableBody(data[prop], level + 1);             \r\n            var colspan = 0;\r\n            for(var j=0;j<subBodyData.length;j++){\r\n              colspan += subBodyData[j].colspan;\r\n              subBodyData[j].elementType = \"object\";\r\n              bodyData.push(subBodyData[j]);\r\n            }  \r\n        }\r\n        else{\r\n          bodyData.push({ title: data[prop], level: level, colspan: 1, elementType: \"primitive\"});\r\n        }\r\n      }\r\n      return bodyData;\r\n    }\r\n  }]\r\n)\r\n\r\n  /**\r\n\t* Directive to denote how the table should look like.\r\n\t* \r\n\t*/\r\n .directive('outputtable', function() {\r\n     return {\r\n        scope: {\r\n            table: '=',\r\n            setData: '&',\r\n            data: '='\r\n        },\r\n        template : '<table  class=\"table table-responsive\"><thead><tr ng-repeat=\"headline in $parent.data.tableHeader\"><th ng-repeat=\"headlineColumn in headline\" rowspan=\"{{headlineColumn.rowspan}}\" colspan=\"{{headlineColumn.colspan}}\">{{headlineColumn.title}}</th></tr></thead><tbody><tr ng-repeat=\"row in $parent.data.tableBody\"><td ng-repeat=\"rowColumn in row\" rowspan=\"{{rowColumn.rowspan}}\" colspan=\"{{rowColumn.colspan}}\">{{rowColumn.title}}</td></tr></tbody></table>',\r\n    \r\n        link: function(scope, el, attr) {\r\n              var thisscope = scope;\r\n\r\n              /**\r\n\t            * Function to watch for changes on the data, if changes happens the data is set to the new data.\r\n\t            * \r\n              * @param {Object} $newvalue - new value of the data.\r\n              * @param {Object} $oldvalue - old value of the data.\r\n\t            */\r\n              scope.$watch('table', function(newvalue, oldvalue) {\r\n            \t  if(newvalue !== undefined)\r\n        \t\t  {\r\n                    thisscope.$parent.setData(newvalue);\r\n        \t\t  }\r\n              }, true);\r\n        }\r\n      };\r\n });\r\n})(window.angular); \r\n\r\n",
    "static": true,
    "longname": "App/outputTable.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 11,
    "kind": "file",
    "name": "App/querybuilder/infoDialog.js",
    "content": "'use strict';\n\nangular.module('queryBuilder.querybuilderInfoDialog', ['ngRoute'])\n\n\n   /**\n   * This controller helps showing informations to the user in a dialog.\n   * The ngDialogData can contain a head and a content.\n   * @version 1.0.0\n   */\n.controller('querybuilderInfoDialogCtrl', ['$requests', '$scope', \n    function($requests, $scope) {\n        var self = this;\n\n          /**\n\t     * The property containing the head and the content.\n\t     * @type {json}\n\t     */\t\n         self.info = $scope.ngDialogData;\n       \n\t\n}]);\n",
    "static": true,
    "longname": "App/querybuilder/infoDialog.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 12,
    "kind": "file",
    "name": "App/querybuilder/loadDialog.js",
    "content": "'use strict';\n\nangular.module('queryBuilder.querybuilderLoadDialog', ['ngRoute'])\n\n\n/**\n * This controller is in charge of loading, filtering and deleting queries.\n * @version 1.0.0\n */\n.controller('querybuilderLoadDialogCtrl', ['$requests', '$scope', \n    function($requests, $scope) {\n        var self = this;\n\n        /**\n         * The entered category for querying the results.\n         * @type {string}\n         */\n        self.category = undefined;\n        /**\n         * The entered name for querying the results.\n         * @type {string} \n         */\n        self.name = undefined;\n        /**\n         * The description category for querying the results.\n         * @type {string}\n         */\n        self.description = undefined;\n\n        /**\n         * The loaded querys.\n         * @type {string}\n         */\n        self.loadedQueries = [ ];    \n\n         /**\n         * The available categories.\n         * @type {string}\n         */\n        self.availableCategories = [];\n\n       /**\n         * The callback when all querys were loaded.\n         *\n         * @param {boolean} $success - true when there are no errors.\n         * @param {json} $data - the requested data (In this case the queries).\n         * @param {number} $status - the actual server status.\n         */\n        self.loadQueriesInBuilderCB = function($success, $data, $status){\n            if($success){\n                self.loadedQueries = $data;\n            }\n        }\n\n\n\t    $requests.loadAllQueriesInBuilder( self.loadQueriesInBuilderCB);\n\n         /**\n         * This method closes this dialog and delivers the query.\n         *\n         * @param {string} $query - delivers the selected query.\n         */\n        self.selectQuery = function($query){\n             $scope.closeThisDialog($query);\n        };\n\n         /**\n         * The callback when the requested query was deleted\n         *\n         * @param {boolean} $success - true when there are no errors.\n         * @param {json} $data - the requested data (In this case no data will be sent).\n        * @param {number} $status - the actual server status.\n         */\n        self.deleteQueryCallback = function($success, $data, $status) {\n            if($success){\n                $requests.loadAllQueriesInBuilder(self.loadQueriesInBuilderCB);\n            }\n            \n        }\n\n         /**\n         * This method deletes a query.\n         *\n         * @param {id} $id - the id of the query which should be deleted.\n         */\n        self.deleteQuery = function($id){\n            $requests.deleteQueryInBuilder($id, self.deleteQueryCallback);\n        }\n\n        /**\n         * This method applies a filter.\n         * It uses the input data name, category and description to apply the filter.\n         *\n         */\n        self.applyFilter = function() {\n            $requests.loadSomeQueriesInBuilder(self.loadQueriesInBuilderCB, self.name, self.category, self.description);\n         }\t\n\n\t   /**\n        * The callback when the requested categories were loaded\n        *\n        * @param {boolean} $success - true when there are no errors.\n        * @param {json} $data - the requested data (In this case the categories).\n        * @param {number} $status - the actual server status.\n        */\n        self.getCategoriesCallBack = function($success, $data, $status){\n            self.hasError = !$success;\n            if($success){\n\n                self.availableCategories = $data;\n            }\n            else\n            {\n                self.error = $data;\n            }\n        }\n        /**\n         * This method loads all categories.\n         */\n        $requests.getAllCategories(self.getCategoriesCallBack);\n\n\n    \n\n\t\n}]);\n",
    "static": true,
    "longname": "App/querybuilder/loadDialog.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 13,
    "kind": "file",
    "name": "App/querybuilder/nodeDialogTemplate.js",
    "content": "'use strict';\n\nangular.module('queryBuilder.querybuildernodedialog', ['ngRoute'])\n\n\n\t/**\n   * The controller which handles the configuration of a node.\n   * It will be opened when a node will be clicked.\n   *\n   * In general, this controller helps to add or remove return attributes,\n   * orderby attributes and filter attributes.\n   * Every certain key (attribute) of a node can have a return, orderby or \n   * filter attribute. If such a attribute is required the json will be \n   * added with the set method.\n   * The possible attributes are first loaded into the keys array.\n   * \n   * @version 1.0.0\n   */\n.controller('queryBuilderNodeDialogCtrl', ['$requests', '$scope', '$rootScope','ngDialog',\n    function($requests, $scope, $rootScope, ngDialog) {\n        var self = this;\n\t    \n\t     /**\n\t     * The property contains all informations about the node.\n\t     * This information is handed in from the query builder.\n\t     * @type {Object}\n\t     */\t\n        self.node = $scope.ngDialogData.node;\n\n           /**\n         * The property contains the author of the query in which the\n         * relationship is contained.\n         * This information is handed in from the query builder.\n         * @type {Object}\n         */ \n        self.author = $scope.ngDialogData.author;\n\n         /**\n\t     * The name of the node.\n\t     * @type {Object}\n\t     */\t\n        self.name = self.node['type'];\n         /**\n\t     *The keys are all possible attributes where one can apply a filter.\n\t     * @type {Object}\n\t     */\t\n        self.keys = [];\n         /**\n\t     * The relations are all existing incoming and outgoing relationship types of a \n         * certain node.\n\t     * @type {Object}\n\t     */\t\n        self.relationships = [];\n\n        /**\n        * The callback when the requested keys were loaded.\n        * The keys are all possible attributes where one can apply a filter.\n        *\n        * @param {boolean} $success - true when there are no errors.\n        * @param {Object} $data - the requested data (In this case the keys).\n        * @param {number} $status - the actual server status.\n        */\n\t\tself.getKeysCB = function($success, $data, $status){\n\t\t\tself.hasError = !$success;\n\t\t\tif($success){\n\t\t\t\tself.keys = $data; \n\t\t\t}\n\t\t};\n\t\t /**\n         * This method loads all keys.\n         * The keys are all possible attributes where one can apply a filter, set it as return attribue or\n         * order the results according to it.\n         */\n\t\t$requests.getKeys(self.node['type'], self.getKeysCB);\n\n\t\t\n\t\t/**\n        * The callback when the requested relations were loaded.\n        * The relations are all existing incoming and outgoing relationship types of this \n        *  node.\n        *\n        * @param {boolean} $success - true when there are no errors.\n        * @param {Object} $data - the requested data (In this case the relations).\n        * @param {number} $status - the actual server status.\n        */\n\t\tself.getRelationsWithNodesCB = function($success, $data, $status){\n\t\t\tself.hasError = !$success;\n\t\t\tif($success){\n\t\t\t\tself.relationships = $data; \n\t\t\t}\n\t\t};\n\n\t\t /**\n         * This method loads all relations.\n         * The relations are all existing incoming and outgoing relationship types of \n         * this node.\n         */\n\t\t$requests.getRelationsWithNodes(self.node['type'], self.getRelationsWithNodesCB);\n\n\n\t\t/******************************\n\t\tADD RELATIONSHIP\n\t\t/******************************/\n\n\t\t/**\n        * This method adds an relationship to this node.\n        *\n        * @param {string} $type - the relationshiptype.\n        * @param {string} $direction - The direction of the relationship (ingoing or outgoing).\n        * @param {Object} $node - The node type where the relationship comes from ore goes to.\n        */\n\t\tself.addRelationship = function($type, $direction, $node){\n\t\t\tself.node['relationship'].push({\n\t\t\t\t\t\"relationshipType\" :$type, \t//hasMethod, hasInstance\n\t\t\t\t\t\"direction\": $direction, \t//ingoing, outgoing\n\t\t\t\t\t\"optional\":false, \t\t\t//OPTIONAL MATCH\n\t\t\t\t\t\"returnAttributes\":[],\n\t\t\t\t\t\"filterAttributes\":[],\n\t\t\t\t\t\"orderByAttributes\":[],\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"type\": $node,\n\t\t\t\t\t\t\"returnAttributes\": [],\n\t\t\t\t\t\t\"filterAttributes\": [],\n\t\t\t\t\t\t\"orderByAttributes\": [],\n\t\t\t\t\t\t\"relationship\":[]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\n\t\t/**\n\t    * This method opens an info dialog. It displays a certain data (head and content)\n\t    * given in the $data. Furthermore, a callback can be specified, when the dialg is closed.\n\t    *\n\t    * @param {!Object} $data - the head an the content for the info dialog.\n\t    * @param {?function} infoClosePromis - The function which should be called when the dialog is closed.\n\t    */\n\t    self.showInfoDialog = function($data, infoClosePromis){\n\t    \tvar dialog = ngDialog.open({ template: 'querybuilder/infoDialog.html',\n\t        \t\t\t\tclassName: 'ngdialog-theme-default custom-width',\n\t        \t\t\t\tcontroller: 'querybuilderInfoDialogCtrl',\n\t        \t\t\t\tcontrollerAs: 'ctrl',\n\t        \t\t\t\tdata:$data\n\t        \t\t });\n\t    \tif(infoClosePromis !== undefined){\n\t    \t\tdialog.closePromise.then(infoClosePromis);\n\t    \t}\n\t    }\n\n\t\t/******************************\n\t\tReturn Attributes\n\t\t/******************************/\n\n\t\t/**\n        * This method searches for a certain return attribute with a certain the attribute name.\n        *\n        * @param {string} $key - The key of the return attribute. The key is the same as the attribute name.\n        * @return {Object} The given return attribute or undefined.\n        */\n\t\tself.getReturnAttributes = function($key){\n\t\t\tvar returnAttribute = undefined;\n\t\t\tfor (var i = self.node['returnAttributes'].length - 1; i >= 0; i--) {\n\t\t\t\tif(self.node['returnAttributes'][i]['attributeName'] === $key){\n\t\t\t\t\treturnAttribute = self.node['returnAttributes'][i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn returnAttribute;\n\t\t};\n\n\t\t/**\n        * Checks whether a certain return attribute with a certain key (attribute name) exists or not.\n        *\n        * @param {string} $key - The return attribute key. The key is the same as the attribute name.\n        * @return {boolean} True if the attribute with the given key exists, otherwise false.\n        */\n\t\tself.isReturnAttributesChecked = function($key){\n\t\t\tif(self.getReturnAttributes($key) === undefined){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t\t/**\n        * Checks whether a certain return attribute with a certain key exists or not.\n        * If it exists it removes the return attribute, if not it creates a return attribute with \n        * the given key. \n        * Every call toggles a certain return attribute with a certain key.\n        * This is necessary because only the keys which should be returned should have an \n        * entry in the returnAttributes array. For one key (attribute name)\n        * there can be only one return attribute.\n        *\n        * @param {string} $key - The key of the property which should be added or deleted.\n        */\n\t\tself.setReturnAttributes = function($key){\n\t\t\tvar returnAttribute = self.getReturnAttributes($key);\n\t\t\tif(returnAttribute !== undefined){\n\t\t\t\t//Deletes the return attribute\n\t\t\t\tvar index = self.node['returnAttributes'].indexOf(returnAttribute);\n\t\t\t\tself.node['returnAttributes'].splice(index, 1);\t\n\n\t\t\t\tif(self.getOrderByAttributes($key) !== undefined){\n\t\t\t\t\tself.setOrderByAttributes($key);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//adds a return attribute\n\t\t\t\tself.node['returnAttributes'].push({\n\t\t\t\t\t\"attributeName\":$key,\n\t\t\t\t\t\"alias\":\"\",\n\t\t\t\t\t\"aggregation\" : \"NONE\"\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\t/**\n        * This method sets a property of a certain return attribute identified by \n        * the key (attribute name).\n        *\n        * @param {string} $key - The key of the return attribute. The key is the same as the attribute name.\n        * @param {string} $type - The property which should be set. \n        * @param {Object} $value - The characteristic of the property ($type).\n        */\n\t\tself.setReturnAttributesValue = function($key, $type, $value){\n\t\t\tvar returnAttribute = self.getReturnAttributes($key);\n\t\t\tif(returnAttribute !== undefined){\n\t\t\t\treturnAttribute[$type] = $value;\n\t\t\t}\n\t\t};\n\n\t\t/******************************\n\t\tORDER BY ATTRIBUTES \n\t\t/******************************/\n\n\t\t/**\n        * This method searches for a certain orderby attribute with a certain attribute name (key).\n        *\n        * @param {string} $key - The key of the orderby attribute. The key is the same as the attribute name.\n        * @return {Object} The given orderby attribute or undefined.\n        */\n\t\tself.getOrderByAttributes = function($key){\n\t\t\tvar orderByAttribute = undefined;\n\t\t\tfor (var i = self.node['orderByAttributes'].length - 1; i >= 0; i--) {\n\t\t\t\tif(self.node['orderByAttributes'][i]['attributeName'] === $key){\n\t\t\t\t\torderByAttribute = self.node['orderByAttributes'][i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn orderByAttribute;\n\t\t};\n\n\t\t/**\n        * Checks whether a certain orberby attribute with a certain key (attribute name) exists or not.\n        *\n        * @param {string} $key - The orberby attribute key. The key is the same as the attribute name.\n        * @return {boolean} True if the attribute with the given key exists, otherwise false.\n        */\n\t\tself.isOrderByAttributesChecked = function($key){\n\t\t\tif(self.getOrderByAttributes($key) === undefined){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\n\t\t/**\n        * Checks whether a certain orberby attribute with a certain key exists or not.\n        * If it exists it removes the orberby attribute, if not it creates a orberby attribute with \n        * the given key. \n        * Every call toggles a certain orberby attribute with a certain key.\n        * This is necessary because only the keys which should be returned should have an \n        * entry in the returnAttributes array. For one key (attribute name)\n        * there can be only one orberby attribute.\n        *\n        * @param {string} $key - The key of the property which should be added or deleted.\n        */\n\t\tself.setOrderByAttributes = function($key){\n\t\t\tvar orderByAttribute = self.getOrderByAttributes($key);\n\t\t\t//Toggle attribute\n\t\t\tif(orderByAttribute !== undefined){\n\t\t\t\t//Deletes the orderby attribute\n\t\t\t\tvar index = self.node['orderByAttributes'].indexOf(orderByAttribute);\n\t\t\t\tself.node['orderByAttributes'].splice(index, 1);\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(self.getReturnAttributes($key) === undefined){\n\t\t\t\t\tself.setReturnAttributes($key);\n\t\t\t\t}\n\t\t\t\t//Adds the orderby attribute\n\t\t\t\tself.node['orderByAttributes'].push({\n\t\t\t\t\t\"attributeName\":$key,\n\t\t\t\t\t\"id\": 1,\n\t\t\t\t\t\"direction\": \"asc\"\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\t/**\n        * This method sets a property of a certain orderby attribute identified by \n        * the key (attribute name).\n        *\n        * @param {string} $key - The key of the orderby attribute. The key is the same as the attribute name.\n        * @param {string} $type - The property which should be set. \n        * @param {Object} $value - The characteristic of the property ($type).\n        */\n\t\tself.setOrderByAttributesValue = function($key, $type, $value){\n\t\t\tvar orderByAttribute = self.getOrderByAttributes($key);\n\t\t\tif(orderByAttribute !== undefined){\n\t\t\t\torderByAttribute[$type] = $value;\n\t\t\t}\n\t\t};\n\t\n\n\t\t/******************************\n\t\tFILTER ATTRIBUTES\n\t\t/******************************/\n\t\t/**\n        * This method searches for a certain filter attribute with a certain attribute name (key).\n        *\n        * @param {string} $key - The key of the filter attribute. The key is the same as the attribute name.\n        * @return {Object} The given filter attribute or undefined.\n        */\n\t\tself.getFilterAttributes = function($key){\t\n\t\t\tfor (var i = self.node['filterAttributes'].length - 1; i >= 0; i--) {\n\t\t\t\tif(self.node['filterAttributes'][i]['attributeName'] === $key){\n\t\t\t\t\treturn self.node['filterAttributes'][i];\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn undefined;\n\t\t};\n\n\t\t/**\n        * Checks whether a certain filter attribute with a certain key (attribute name) exists or not.\n        *\n        * @param {string} $key - The filter attribute key. The key is the same as the attribute name.\n        * @return {boolean} True if the attribute with the given key exists, otherwise false.\n        */\n\t\tself.isFilterAttributesChecked = function($key){\n\t\t\tif(self.getFilterAttributes($key) === undefined){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t\t/**\n        * Checks whether a certain filter attribute with a certain key exists or not.\n        * If it exists it removes the filter attribute, if not it creates a filter attribute with \n        * the given key. \n        * Every call toggles a certain filter attribute with a certain key.\n        * This is necessary because only the keys which should be returned should have an \n        * entry in the returnAttributes array. For one key (attribute name)\n        * there can be only one filter attribute.\n\t\t*\n\t\t* Because a filter attribute can also have relations between each other, this \n\t\t* method handles the relations by setting the logic attribute. If two attributes are\n\t\t* combined by this logic, the first holds the logic.\n\t\t* \n\t\t* If a new attribute is added, \n\t\t* this method also adds the logic to the previous attribute. \n\t\t* If the last attribute is removed the logic\n\t\t* of the attribute before it is also removed.\n\t\t* \n        * This works because the filter attributes are ordered alphabetically.\n        * \n        * @param {string} $key - The key of the property which should be added or deleted.\n        */\n\t\tself.setFilterAttributes = function($key){\n\t\t\tvar filterAttribute = self.getFilterAttributes($key);\n\t\t\tif(filterAttribute !== undefined){\n\t\t\t\t\n\t\t\t\tvar index = self.node['filterAttributes'].indexOf(filterAttribute);\n\t\t\t\t\n\t\t\t\tif(self.node['filterAttributes'].length - 1 === index && index !== 0){\n\t\t\t\t\tself.node['filterAttributes'][index - 1].logic = \"\";\n\t\t\t\t}\n\t\t\t\tself.node['filterAttributes'].splice(index, 1);\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t\n\t\t\t\tvar newFilterAttribute = {\n\t\t\t\t\t\t\"attributeName\":$key,\n\t\t\t\t\t\t\"logic\":\"\",\n\t\t\t\t\t\t\"filters\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"id\":0,\t\t\t//for Frontend\n\t\t\t\t\t\t\t\t\"type\":\"string\",\t\t //int, string...\n\t\t\t\t\t\t\t\t\"filterType\": \"=\", \t// \"in\",\"like\",\"=\",\">\"\n\t\t\t\t\t\t\t\t\"value\":\"\", \n\t\t\t\t\t\t\t\t\"changeable\":true,\n\t\t\t\t\t\t\t\t\"isBracketOpen\": false,\n\t\t\t\t\t\t\t\t\"isBracketClosed\": false,\n\t\t\t\t\t\t\t\t\"logic\":\"\"  \t\t\t//“AND/OR”\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\t//ist der Parameter fix oder in der Verwaltung veränderbar?\n\t\t\t\t};\n\n\t\t\t\t//adds and attribute\n\t\t\t\tself.node['filterAttributes'].push(\n\t\t\t\t\tnewFilterAttribute\n\t\t\t\t);\n\t\t\t\t//sort alphabetically\n\t\t\t\tself.node['filterAttributes'] = self.node['filterAttributes'].sort(function(x, y) {\n\t\t\t        if (x['attributeName'] == y['attributeName']) return 0;\n\t\t\t        else if (x['attributeName'] < y['attributeName']) return -1;\n\t\t\t        else return 1;\n\t\t\t    });\n\t\t\t\t//add logic to index +1 and index - 1 if not available\n\t\t\t    var index = self.node['filterAttributes'].indexOf(newFilterAttribute);\n\n\t\t\t    if(index > 0){\n\t\t\t\t\tif(self.node['filterAttributes'][index - 1].logic === \"\" ||\n\t\t\t\t\t\tself.node['filterAttributes'][index - 1].logic === undefined){\n\t\t\t\t\t\tself.node['filterAttributes'][index - 1].logic = \"AND\";\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif(self.node['filterAttributes'].length - 1 > index  ){\n\t\t\t\t\tself.node['filterAttributes'][index].logic = \"AND\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tconsole.log(self.node);\n\t\t};\n\n\t\t/**\n        * This method sets a property of a certain filter attribute identified by \n        * the key (attribute name).\n        *\n        * @param {string} $key - The key of the filter attribute. The key is the same as the attribute name.\n        * @param {string} $type - The property which should be set. \n        * @param {Object} $value - The characteristic of the property ($type).\n        */\n\t\tself.setFilterAttributesValue = function($key, $type, $value){\n\t\t\tvar filterAttributes = self.getFilterAttributes($key);\n\n\t\t\tif(filterAttributes != undefined\n\t\t\t\t&& filterAttributes[$type] !== $value){\n\t\t\t\tfilterAttributes[$type] = $value;\n\t\t\t}\n\n\t\t\tconsole.log(\"Set key: \" + $key + \", type: \" + $type + \n\t\t\t\t\t\t\t\", value: \" + $value );\n\t\t};\n\n\t\t/**\n        * A filter attribute contains multiple (at least one) filter. Each filter is \n        * identified by an id. \n        * This method searches for a certain filter identified by an id\n        * in a certain filter attribute identified a certain attribute name (key).\n        *\n        * @param {string} $key - The key of the filter attribute. The key is the same as the attribute name.\n        * @param {string} $id - The id of the specific filter. \n        * @return {Object} The given filter attribute or undefined.\n        */\n\t\tself.getFilterAttributesFilter = function($key, $id){\n\t\t\tvar filterAttributes = self.getFilterAttributes($key);\n\n\t\t\tif(filterAttributes !== undefined && \n\t\t\t\tfilterAttributes.filters !== undefined){\n\t\t\t\tfor (var i = filterAttributes.filters.length - 1; i >= 0; i--) {\n\t\t\t\t\tif(filterAttributes.filters[i].id === $id){\n\t\t\t\t\t\treturn filterAttributes.filters[i];\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t}\n\n\t\t\n\t\t/**\n        * This method sets a property of a certain filter identified by an id in\n        * a certain filter attribute identified by an attribute name (key).\n        *\n        * @param {string} $key - The key of the filter attribute. The key is the same as the attribute name.\n        * @param {string} $id - The id of the specific filter. \n        * @param {string} $type - The property which should be set. \n        * @param {Object} $value - The characteristic of the property ($type).\n        */\n\t\tself.setFilterAttributesFilterValue = function($key, $id, $type, $value){\n\t\t\tvar filterAttributesFilter = self.getFilterAttributesFilter($key, $id);\n\n\t\t\tif(filterAttributesFilter != undefined\n\t\t\t\t&& filterAttributesFilter[$type] !== $value){\n\t\t\t\tfilterAttributesFilter[$type] = $value;\n\n\t\t\t\tif($type === 'type'){\n\t\t\t\t\tfilterAttributesFilter['value'] = undefined; \n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconsole.log(\"Set key: \" + $key + \", type: \" + $type + \n\t\t\t\t\t\t\t+ \", id: \" + $id + \", value: \" + $value );\n\t\t};\n\n\t\t/**\n        * This method adds a filter to a filter attribute.\n        * The new filter will have a unique id.\n        * This method also sorts the filter attributes by the id.\n        * The filter attributes were combined with a certain logic (AND, OR) within  \n        * a certain filter attributes. This method initializes also the logic.\n        *\n        * @param {string} $key - The key of the filter attribute in which the filter should be added.\n        */\n\t\tself.addFilterAttributesFilter = function($key){\n\n\t\t\tvar filterAttributes = self.getFilterAttributes($key);\n\n\t\t\tif(\tfilterAttributes !== undefined &&\n\t\t\t\tfilterAttributes !== null &&\n\t\t\t\tfilterAttributes.filters !== undefined &&\n\t\t\t\tfilterAttributes.filters !== null ){\n\t\t\t\t//sort filters ascending\n\t\t\t\tfilterAttributes.filters.sort(function(x, y) {\n\t\t\t        if (x['id'] == y['id']) return 0;\n\t\t\t        else if (parseInt(x['id']) < parseInt(y['id'])) return -1;\n\t\t\t        else return 1;\n\t\t\t    });\n\t\t\t\t//there must be at least one filter in the filters array\n\t\t\t\t//otherwise: invalid state\n\n\t\t\t\tif(filterAttributes.filters.length > 0){\n\t\t\t\t\tfilterAttributes.filters[filterAttributes.filters.length - 1].logic = \"AND\";\n\t\t\t\t}\n\n\t\t\t\tvar id = filterAttributes.filters[filterAttributes.filters.length - 1].id;\n\t\t\t\tid = id +1;\n\t\t\t\tfilterAttributes.filters.push(\n\t\t\t\t{\n\t\t\t\t\t\"id\":id,\t\t\t//for Frontend\n\t\t\t\t\t\"type\":\"string\",\t//int, string...\n\t\t\t\t\t\"filterType\": \"=\", \t//like \"in\",\"like\",\"=\",\">\"\n\t\t\t\t\t\"value\":\"\", \n\t\t\t\t\t\"changeable\":false,\n\t\t\t\t\t\"isBracketOpen\": false,\n\t\t\t\t\t\"isBracketClosed\": false,\n\t\t\t\t\t\"logic\":\"\"  \t\t//“AND/OR”\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\n\t\t/**\n        * This method removes a filter identified by an id of a filter attribute\n        * identified by the attribute name (key).\n        *\n        * The filter attributes werew combined with a certain logic (AND, OR). \n        * If required, this method deletes this logic too.\n        *\n        * @param {string} $key - The key of the filter attribute in which the filter should be removed.\n        * @param {string} $id - The id of the specific filter which should be removed. \n        */\n\t\tself.deleteFilterAttributesFilter = function($key, $id){\n\t\t\tvar filterAttributes = self.getFilterAttributes($key);\n\n\t\t\tif(filterAttributes !== undefined){\n\t\t\t\t//There must be at least one filter in the array\n\t\t\t\tif(filterAttributes.filters != undefined &&\n\t\t\t\t\tfilterAttributes.filters.length > 1){\n\t\t\t\t\t//Delete filter\n\t\t\t\t\tvar filterAttributesFilter = self.getFilterAttributesFilter($key, $id);\n\t\t\t\t\tif(filterAttributesFilter != undefined){\n\t\t\t\t\t\tvar index = filterAttributes.filters.indexOf(filterAttributesFilter);\n\t\t\t\t\t\tif(filterAttributes.filters.length - 1 === index && index !== 0){\n\t\t\t\t\t\t\tfilterAttributes.filters[index - 1].logic = \"\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfilterAttributes.filters.splice(index, 1);\t\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\n\t\t /**\n         * This function checks wheather a user has the  \n         * permission to edit the items or not.\n         *\n         * @param {string} $attributeType - The type of the attribute -> \"filter\", \"return\", \"orderby\"\n         * @param {string} $key - The key of the attribute for which the permissions should be cheked. \n         * @param {Object} $additionalInfo - Additional informations.\n         * @return {boolean} Returns optional property.\n         */ \n        self.hasPermissions = function($attributeType, $key, $additionalInfo){\n            if(self.author === $rootScope.principal.username){\n            \t//the author can do everything\n                return true;\n            }\n            else {\n            \t//permission is only granted to filter attributes\n            \tif($attributeType === \"filter\" && $additionalInfo != undefined &&\n            \t\t$additionalInfo.type != undefined && $additionalInfo.id != undefined &&\n            \t\t$additionalInfo.type != \"changeable\"){\n\n            \t\tvar filterAttributesFilter = self.getFilterAttributesFilter($key, $additionalInfo.id);\n            \t\tif(filterAttributesFilter.changeable){\n            \t\t\treturn true;\n            \t\t}\n            \t\treturn false;\n            \t\t\n            \t}\n                return false;\n            }\n        }\n}]);\n",
    "static": true,
    "longname": "App/querybuilder/nodeDialogTemplate.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 14,
    "kind": "file",
    "name": "App/querybuilder/querybuilder.js",
    "content": "'use strict';\n\nangular.module('queryBuilder.querybuilder', ['ngRoute', 'queryBuilder.services'])\n\n.config(['$routeProvider', function($routeProvider) {\n  $routeProvider.when('/querybuilder', {\n    templateUrl: 'querybuilder/querybuilder.html'\n  });\n}])\n/**\n   * This controller handles the main operation in the user interface.\n   * It configures vis.js, opens a dialog when a node or a relationship was clicked, \n   * draws the graph, executes the query and saves or updates the query.  \n   * \n   * @version 1.0.0\n   */\n.controller('queryBuilderCtrl', ['$requests', '$rootScope', '$scope','ngDialog',\n\tfunction($requests, $rootScope, $scope, ngDialog) {\n    var self = this;\n\n     /**\n     * The query which will be built with the query builder.\n     * This saves the core information about the query.\n     * @type {Object}\n     */\n    self.query = {\n    \t\"id\":\"\",\n    \t\"name\":\"\",\n        \"author\":  $rootScope.principal.username,\n    \t\"description\":\"\",\n    \t\"category\":\"\",\n    \t\"limitCount\": \"\",\n        \"skip\":\"\",\n    \t\"distinct\":false,\n    \t\"node\":\"\"          \n    }\n\n\n    /**\n     * The cypher query which is displayed to the user.\n     * @type {string}\n     */\n   \tself.displayQuery = \"\";\n\n   \t/**\n     * The node ID Store saves the id of the node in the vis.js network with\n     * the corresponding node in the query.\n     * @type {Object}\n     */\n    self.nodeIDStore = {};\n    /**\n     * The relationship ID Store saves the id of the relationship\n     * in the vis.js network with\n     * the corresponding relationship in the query.\n     * @type {Object}\n     */\n    self.relationshipIDStore = {};\n    /**\n     * Holds the selected node from the vis network.\n     * @type {Object}\n     */\n    self.selectedNode = undefined;\n\n    /**\n     * Holds the selected releation from the vis network.\n     * @type {Object}\n     */\n    self.selectedRelation = undefined;\n\t /**\n     * Holds the selected releation from the vis network.\n     * @type {Object}\n     */\n\tself.availableNodes = \"\";\n\n\t /**\n     * Holds the data for the output table in the querybuilder network.\n     * The table is only shown when the hasError property is set to FALSE.\n     * @type {Object}\n     */\n\tself.table = \"\";\n\t /**\n     * If there was an error during the execution of the query this is set to \n     * true and the error will be displyed. Otherwise the table will be displayed.\n     * @type {boolean}\n     */\n\tself.hasError = false;\n\t /**\n     * Holds the error string which is displayed to the user.\n     * The table is only shown when the hasError property is set to TRUE.\n     * @type {string}\n     */\n\tself.error = \"\";\n\n\t /**\n     * Holds all available categories.\n     * @type {Object}\n     */\n\tself.availableCategories = [];\n   \n   \t/**\n   \t * Transfers the actual query into a graph \n   \t * which can be displayed with vis.js.\n\t * This method will be called whenever the self.query property\n     * changes. \n     * Furthermore, this method creates the ids for the nodes and for the \n     * relationships which are required for the vis.js network.\n   \t * In order to find out, which id corresponds to which node or to which relationship in \n   \t * the query a relationshipIDStore and a nodeIDStore is needed.\n   \t *\n   \t * @param {visnetwork} $network - the network behind the vis graph (optional).\n   \t */\n    self.transfersToGraph = function($network){\n    \tvar $nodeID = 1;\n    \tvar $relationshipID = 0;\n\n    \tfor (var id in self.relationshipIDStore) {\n\t\t  if (self.relationshipIDStore.hasOwnProperty(id)) {\n\t\t    self.edges.remove(id);\n\t\t  }\n\t\t}\n\n    \tfor (var id in self.nodeIDStore) {\n\t\t  if (self.nodeIDStore.hasOwnProperty(id)) {\n\t\t    self.nodes.remove(id);\n\t\t  }\n\t\t}\n\n    \tself.nodeIDStore = {};\n    \tself.relationshipIDStore = {};\n\n    \tfunction transfersToGraphRecursion($parrentid, $relationship){\n    \t\tvar $node = $relationship['node'];\n\n    \t\tif($node != undefined){\n \n    \t\t\t$nodeID = $nodeID + 1;\n    \t\t\t$relationshipID = $relationshipID +1;\n    \t\t\t//save variable value because $nodeId and $relationship id can be changed by a other\n    \t\t\t//execution\n    \t\t\tvar $nID = $nodeID;\n    \t\t\tvar $rID = $relationshipID;\n\n    \t\t\tself.nodes.add([{id: $nID, label: $node['type']}]);\n    \t\t\tif($relationship['direction'] === \"INGOING\"){\n  \t\t\t\t\tself.edges.add([{id: $rID, from: $nID, to: $parrentid, label: $relationship['relationshipType']}]);\n    \t\t\t}\n    \t\t\telse{\n    \t\t\t\tself.edges.add([{id: $rID, from: $parrentid, to: $nID, label: $relationship['relationshipType']}]);\n    \t\t\t}\n\n    \t\t\tself.nodeIDStore[$nID] = $node;\n    \t\t\tself.relationshipIDStore[$rID] = $relationship;\n\n    \t\t\tif($node[\"relationship\"] != undefined){\n    \t\t\t\tfor (var i = 0; i < $node[\"relationship\"].length; i++){\n\t\t\t\t\t    var rel = $node[\"relationship\"][i];\n\t\t\t\t\t    transfersToGraphRecursion($nID, rel);\n\t\t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n\n    \tif(self.query[\"node\"] !== undefined ){\n\n    \t\t\tvar $rootNode = self.query[\"node\"];\n    \t\t \t//Root node\n    \t\t\t self.nodes.add([{id: 1, label: $rootNode[\"type\"], color: '#009900'}]);\n    \t\t\t self.nodeIDStore[1] = $rootNode;\n\n    \t\t\t //every additional node\n    \t\t\t if($rootNode[\"relationship\"] != undefined){\n    \t\t\t\tfor (var i = 0; i < $rootNode[\"relationship\"].length; i++){\n\t\t\t\t\t    var rel = $rootNode[\"relationship\"][i];\n\t\t\t\t\t    transfersToGraphRecursion(1, rel);\n\t\t\t\t\t}\n    \t\t\t}\n    \t}\n    \tif($network !== undefined){\n    \t\t$network.fit();\n    \t\t$network.redraw();\n    \t}\n    \t\n    };\n\n  \t /**\n    * This method opens an info dialog. It displays a certain data (head and content)\n    * given in the $data. Furthermore, a callback can be specified, when the dialg is closed.\n    *\n    * @param {!Object} $data - the head an the content for the info dialog.\n    * @param {?function} infoClosePromis - The function which should be called when the dialog is closed.\n    */\n    self.showInfoDialog = function($data, infoClosePromis){\n    \tvar dialog = ngDialog.open({ template: 'querybuilder/infoDialog.html',\n        \t\t\t\tclassName: 'ngdialog-theme-default custom-width',\n        \t\t\t\tcontroller: 'querybuilderInfoDialogCtrl',\n        \t\t\t\tcontrollerAs: 'ctrl',\n        \t\t\t\tdata:$data\n        \t\t });\n    \tif(infoClosePromis !== undefined){\n    \t\tdialog.closePromise.then(infoClosePromis);\n    \t}\n    }\n\t\n     /**\n    * This method checks whether a query is valid before updating and saving.\n    * Only valid queries should be sent to the server.\n    * \n    * @return {Object} The error message or undefined.\n    */\n\tself.checkInputData = function(){\n\t\tvar $data = undefined;\n\t\tif(self.query.name === \"\" || self.query.name === undefined\n\t\t\t|| self.query.name === null){\n\t\t\t$data = {\n\t\t\t\t\"head\":\"No name\",\n\t\t\t\t\"content\":\"Please enter a name before you save/update the query.\"\n\t\t\t};\n\t\t}\n\t\telse if(self.query.description === \"\"|| self.query.description === undefined\n\t\t\t|| self.query.description === null){\n\t\t\t$data = {\n\t\t\t\t\"head\":\"No description\",\n\t\t\t\t\"content\":\"Please enter a description before you save/update the query.\"\n\t\t\t};\n\t\t}\n\t\telse if(self.query.category === \"\"|| self.query.category === undefined\n\t\t\t|| self.query.category === null){\n\t\t\t$data = {\n\t\t\t\t\"head\":\"No category\",\n\t\t\t\t\"content\":\"Please enter a category before you save/update the query.\"\n\t\t\t};\n\t\t}\n\t\telse if(self.query.node === \"\"|| self.query.node === undefined\n\t\t\t|| self.query.node === null){\n\t\t\t$data = {\n\t\t\t\t\"head\":\"No node\",\n\t\t\t\t\"content\":\"Please enter a node before you save/update the query.\"\n\t\t\t};\n\t\t}\n    \treturn $data;\n\t}\n\n\t  /**\n        * The callback when the requested query was loaded.\n        * The query is the cypher query which is displayed to the user.\n        *\n        * @param {boolean} $success - true when there are no errors.\n        * @param {Object} $data - the requested data (In this case the query).\n        * @param {number} $status - the actual server status.\n        */\n\tself.getQueryCallback = function($success, $data, $status){\n\t\tif($success){\n\t\t\tself.displayQuery = $data;\n\t\t\t$rootScope.queryBuilderQueryInCypher = $data.query;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tself.displayQuery = \"\";\n\t\t\t$rootScope.queryBuilderQueryInCypher = undefined;\n\t\t}\n    }\n\n    /**\n     * This method should be (will be) called every time the query changes.\n     * It saves a copy of the actual query to the root scope. This is \n     * necessary if the user switches tabs he wants to have the same \n     * query when he comes back. Furthermore, the cypher query will be created.\n     */\n    self.onQueryChanged = function(){\n    \t$rootScope.queryBuilderOldQuery = self.query;\n    \t$requests.getQueryFromQueryQueryBuilder(self.query, self.getQueryCallback);\n    }\n\n   \n \t/**\n    * The callback is executed when the query is executed.\n    * If there is an error in the query the error will be displayed otherwise the\n    * result.\n    *\n    * @param {boolean} $success - true when there are no errors.\n    * @param {Object} $data - the requested data (The error or the result of the query.).\n    * @param {number} $status - the actual server status.\n    */\n\tself.executeQueryCallback = function($success, $data, $status) {\n\t\tself.hasError = !$success;\n\t\tif($success){\n\t\t\tself.table = $data;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tself.error = $data;\n\t\t}\n\t}\n\n\t /**\n     * This method executes a query and displays the result in a table \n     * or displays the error message.\n     */\n\tself.executeQuery = function() {\n\t\tself.onQueryChanged();\n\t\t$requests.getResultFromQueryQueryBuilder(self.query, self.executeQueryCallback);\n\t}\n\n\t  /**.\n        * The callback when user requested to save the query.\n        * This method displays a success or an error message to the user.\n        * Only new queries can be saved. If an existing should be saved an\n        * update needs to be done.\n        *\n        * @param {boolean} $success - true when there are no errors.\n        * @param {Object} $data -. the requested data (The new id of the query).\n        * @param {number} $status - the actual server status.\n        */\n\tself.saveQueryCallback = function($success, $data, $status) {\n\t\tvar $dataForDialog = undefined;\n\t\tif($success){\n\t\t\t$dataForDialog = {\n\t\t\t\t\"head\":\"Successfully saved\",\n\t\t\t\t\"content\":\"The query was saved successfully.\"\n\t\t\t};\n\t\t\tself.query.id = $data;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$dataForDialog = {\n\t\t\t\t\"head\":\"Error when saving\",\n\t\t\t\t\"content\":\"Error when saving the query. Info: \" + $data\n\t\t\t};\n\t\t}\n\n\t\t self.showInfoDialog($dataForDialog);\n\n\t\t\n\t}\n\n\t /**\n     * This method saves a query and displays if the process was successful or not.\n     * Only new queries can be saved. If an existing should be saved an\n     * update needs to be done.\n     */\n\tself.saveQuery = function(){\n\t\tvar $data =self.checkInputData();\n\n    \tif($data === undefined){\n\n    \t\t$requests.saveQueryInBuilder(self.query, self.saveQueryCallback);\n    \t}\n    \telse\n    \t{\n    \t\tself.showInfoDialog($data);\n    \t}\n\t\tself.onQueryChanged();\n\t}\n\n\t  /**.\n        * The callback when user requested to update the query.\n        * This method displays a success or an error message to the user.\n        * Before one can do an update, the query must be saved first.\n        *\n        * @param {boolean} $success - true when there are no errors.\n        * @param {Object} $data - useless, because no data was requested.\n        * @param {number} $status - the actual server status.\n        */\n\tself.updateQueryCallback = function($success, $data, $status) {\n\t\tvar $data = undefined;\n\t\tif($success){\n\t\t\t$data = {\n\t\t\t\t\"head\":\"Successfully updated\",\n\t\t\t\t\"content\":\"The query was updated successfully.\"\n\t\t\t};\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$data = {\n\t\t\t\t\"head\":\"Error when updating\",\n\t\t\t\t\"content\":\"Error when updating the query. Info: \" + $data\n\t\t\t};\n\t\t}\n\n\t\t self.showInfoDialog($data);\t\n\t}\n\n\t/**\n\t * This method updates a certain query.\n\t * This method displays a success or an error message to the user.\n     * Before one can do an update, the query must be saved first.\n\t */\n\tself.updateQuery = function(){\n\t\tvar $data =self.checkInputData();\n\t\tif($data === undefined){\n    \t\t$requests.updateQueryInBuilder(self.query, self.query.id, self.updateQueryCallback);\n    \t}\n    \telse\n    \t{\n    \t\tself.showInfoDialog($data);\n    \t}\n\t\tself.onQueryChanged();\n\t}\n\n\n\t/**\n\t * This method contains the logic for loading a query.\n\t * It sets all the paramerters according to the data of the query.\n\t * (Initializes vis.js, load initial nodes if they are required, shows cypher query, e.g.)\n\t * \n\t * @param {Object} $query - the query which should be loaded.\n\t */\n\tself.loadQueryLogic = function($query){\n\t\tif( $query !== undefined &&\n    \t\t$query.name !== undefined &&\n    \t\t$query.description !== undefined &&\n    \t\t$query.category !== undefined)\n    \t{\n    \t\tself.query = $query;\n    \t\tself.selectedNode = undefined;\n    \t\tself.selectedRelation = undefined;\n    \t\tself.table = \"\";\n    \t\tself.onQueryChanged();\n    \t\tself.hasError = false;\n\n    \t\t//checks weather query has already properties or is empty\n    \t\tif(\n    \t\t   $query.node !== undefined &&\n    \t\t   $query.node !== \"\" &&\n    \t\t   $query.node.type !== undefined &&\n    \t\t   $query.node.type !== \"\" )\n    \t\t{\n    \t\t   \tself.availableNodes =  [];\n    \t\t}\n    \t\telse{\n    \t\t\t$requests.getNodes(self.getNodesCB);\n    \t\t}\n\t     \tself.transfersToGraph(self.network);\n            self.hasPermissions = (self.query.author === $rootScope.principal.username);\n    \t}\n\t}\n\n\n\t/**\n\t * This method opens the load query dialog.\n\t * If the user selects a certain query it loads it.\n\t */\n\tself.loadQuery = function(){\n\t\tvar dialog = ngDialog.open({ template: 'querybuilder/loadDialog.html',\n\t        \t\t\t\tclassName: 'ngdialog-theme-default custom-width',\n\t        \t\t\t\tcontroller: 'querybuilderLoadDialogCtrl',\n\t        \t\t\t\tcontrollerAs: 'ctrl'});\n\n\n        dialog.closePromise.then(function ($data) {\n        \tif($data !== undefined)\n        \t{\n        \t\tself.loadQueryLogic($data.value);\n        \t}\n\t\t});\n\t}\n\n\n\t\n\n   /**.\n    * The callback when user requested to delete the query.\n    * This method displays a success or an error message to the user.\n    *\n    * @param {boolean} $success - true when there are no errors.\n    * @param {Object} $data - useless, because no data was requested.\n    * @param {number} $status - the actual server status.\n    */\n\tself.deleteQueryCallback = function($success, $data, $status) {\n\t\tvar $data = undefined;\n\t\tif($success){\n\t\t\t$data = {\n\t\t\t\t\"head\":\"Successfully deleted\",\n\t\t\t\t\"content\":\"The query was saved successfully deleted.\"\n\t\t\t};\n\t\t\tself.newQuery();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$data = {\n\t\t\t\t\"head\":\"Error when deleting\",\n\t\t\t\t\"content\":\"Error when deleting the query. Info: \" + $data\n\t\t\t};\n\t\t}\n\t\t\n\t\t self.showInfoDialog($data);\n\t}\n\n\t/**\n\t * This method deletes a certain query.\n\t * It needs the id from the actual query.\n\t */\n\tself.deleteQuery = function(){\n\t\t$requests.deleteQueryInBuilder(self.query.id, self.deleteQueryCallback);\n\t\t\n\t}\n\n\t/**\n\t * This method creates a new query by overwriting the actutal one.\n\t */\n\tself.newQuery = function(){\n\t\tvar query = {\n\t\t\t\"id\":\"\",\n            \"name\":\"\",\n            \"author\":  $rootScope.principal.username,\n            \"description\":\"\",\n            \"category\":\"\",\n            \"limitCount\": \"\",\n            \"skip\":\"\",\n            \"distinct\":false,\n            \"node\":\"\"      \n\t    }\n\t    self.loadQueryLogic(query);\n\t}\n\n\n\t/**\n    * The callback when the requested categories were loaded\n    *\n    * @param {boolean} $success - true when there are no errors.\n    * @param {Object} $data - the requested data (In this case the categories).\n    * @param {number} $status - the actual server status.\n    */\n\tself.getCategoriesCallback = function($success, $data, $status){\n\t\tif($success){\n\t\t\tself.availableCategories = $data;\n\t\t}\n\t}\n\t/**\n\t * This command loads all categories.\n\t */\n\t$requests.getAllCategories(self.getCategoriesCallback);\n\n\t /**\n   \t * The callback when the requested nodes were loaded.\n     * The nodes are all node types that exist in the database.\n     *\n     * @param {boolean} $success - true when there are no errors.\n     * @param {Object} $data - the requested data (In this case the nodes).\n     * @param {number} $status - the actual server status.\n     */\n\tself.getNodesCB = function($success, $data, $status){\n\t\tself.hasError = !$success;\n\t\tif($success){\n\t\t\tself.availableNodes = $data;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tself.error = $data;\n\t\t}\n\t}\n\n\t /**\n   \t * This method adds the first node to a query.\n   \t * The next nodes will be added with the nodeDialog.\n     *\n     * @param {string} $type - the type of the node.\n     */\n\tself.addNode = function($type){\n\t\t/**\n\t\tAdd initial node\n\t\t*/\n\t\tself.query['node'] = {\n\t\t\t\"type\": $type,\n\t\t\t\"returnAttributes\": [],\n\t\t\t\"filterAttributes\": [],\n\t\t\t\"orderByAttributes\": [],\n\t\t\t\"relationship\":[]\n\t\t}\n\t\t\n\n\t\tself.availableNodes = [];\n\t\tself.onQueryChanged();\n\t\tself.transfersToGraph(self.network);\n\t}\n\n\t /**\n   \t * This method searches the selected node and deletes it.\n   \t * The selected node is saved in the property self.selectedNode. It firsts\n   \t * checks whether the first node is the head node of the query.\n   \t * If not, then it searches for the node in the query relationship tree and deletes it.\n     */\n\tself.deleteSelectedNode = function(){\n\t\t//if node is head\n\t\tif(self.query.node ===  self.selectedNode){\n\t\t\tself.selectedNode = undefined;\n\t\t\tself.selectedRelation = undefined;\n\t\t\tself.query.node = undefined;\n\t\t\tself.table = \"\";\n\t\t\tself.hasError = false;\n\t\t\t$requests.getNodes(self.getNodesCB);\n\t\t}\n\t\t//if node is not head\n\t\telse{\n\t\t\tif(self.deleteRecursion(self.query.node, self.selectedNode) === 1){\n\t\t\t\tself.selectedNode = undefined;\n\t\t\t\tself.selectedRelation = undefined;\n\t\t\t};\n\t\t}\n\t\tself.onQueryChanged();\n\t\tself.transfersToGraph(self.network);\n\t\t$scope.$apply();\n\t}\n\n\t/**\n   \t * This method deletes the $nodeToDelete in the $nodeToCheck tree.\n   \t * It goes along each relationship and searches for the right node.\n   \t *\n   \t * @param {Object} $nodeToCheck - The node tree.\n     * @param {Object} $nodeToDelete - The node which should be deleted.\n     * @return {number} O if this is the node which should be deleted. \n     *\t\t\t\t\t1 if the node was deleted. \n     *\t\t\t\t\t2 if the node was not found.\n     */\n\tself.deleteRecursion = function($nodeToCheck, $nodeToDelete){\n\t\tif($nodeToCheck === $nodeToDelete){\n\t\t\treturn 0; //delte node;\n\t\t}\n\t\telse {\n\t\t\tfor (var i = $nodeToCheck.relationship.length - 1; i >= 0; i--) {\n\t\t\t\tvar res = self.deleteRecursion($nodeToCheck.relationship[i].node, $nodeToDelete);\n\t\t\t\tif(res === 0) //delete node\n\t\t\t\t{\n\t\t\t\t\t$nodeToCheck.relationship.splice(i, 1);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\telse if(res === 1) { //node already deleted\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\t//if(res === 2) node not found.\n\t\t\t}\n\t\t\treturn 2;//not found\n\t\t}\n\t}\n\n\t/**\n\tVis settings\n\t*/\n\t /**\n     * The network used in vis.js.\n     * @type {Object}\n     */\n\tself.network = undefined;\n\t /**\n     * The representation of the nodes in vis.js.\n     * @type {Object}\n     */\n\tself.nodes = new vis.DataSet();\n\t /**\n     * The representation of the edges in vis.js.\n     * The edges represnt the relationships.\n     * @type {Object}\n     */\n    self.edges = new vis.DataSet();\n\n    /**\n     * The date for the vis.js network. \n     * @type {Object}\n     */\n    self.network_data = {\n        nodes: self.nodes,\n        edges: self.edges\n    };\n\n     /**\n     * The options for the vis.js network.\n     * For further documentation, please look at the vis.js website.\n     * http://visjs.org/docs/network/\n     * @type {Object}\n     */\n    self.network_options = {\n    \t\n    \twidth:  '100%',\n    \theight: '500px',\n\t\tedges:{\n\t\t    arrows: {\n\t\t      to:     {enabled: true, scaleFactor:1, type:'arrow'},\n\t\t      middle: {enabled: false, scaleFactor:1, type:'arrow'},\n\t\t      from:   {enabled: false, scaleFactor:1, type:'arrow'}\n\t\t    }\n\t\t},\n\t\tlayout: {\n\t\t\trandomSeed: 50,\n\n\t\t\thierarchical: {\n\t\t      enabled:true,\n\t\t      levelSeparation: 150,\n\t\t      nodeSpacing: 100,\n\t\t      treeSpacing: 200,\n\t\t      blockShifting: true,\n\t\t      edgeMinimization: false,\n\t\t      parentCentralization: true,\n\t\t      direction: 'UD',        // UD, DU, LR, RL\n\t\t      sortMethod: 'directed'   // hubsize, directed\n\t\t    }\n\t\t},\n\t\tinteraction:{\n\t\t    zoomView: false,\n\t\t    navigationButtons: true,\n\t      \tkeyboard: true\n\t\t}\n\t};\n\n\n     /**\n     * This method is called whenever a node or an edge was double clicked.\n     * It opens the edge or the node dialog.\n     *\n     * @param {Object} params - The parameters from the vis.js double click event. Further information: http://visjs.org/docs/network/\n     * @param {Object} network - The actual network, which is displayed in the query builder.\n     */\n\tself.onDoubleClick = function(params, network){\n\t\tvar openNodeDialog = false;\n\t\tvar openEdgeDialog = false;\n\t\tif(params.nodes.length > 0){\n\t\t\t openNodeDialog = true;\n\t\t}\n\t\telse if(params.edges.length > 0){\n\t\t\t openEdgeDialog = true;\n\t\t}\n\t\t\n\t\tif(openNodeDialog){\n\t\t\tself.openNodeDialog (params, network);\n\t\t}\n\n\t\tif(!openNodeDialog && openEdgeDialog){\n\t\t\tself.openEdgeDialog (params, network);\n\t\t}\n\t}\n\t/**\n     * This method is called whenever a node or an edge was selected.\n     * It saves the selected node and the selected edge.\n\t *\n     * @param {Object} params - The parameters from the vis.js Select click event. Further information: http://visjs.org/docs/network/\n     * @param {Object} network - The actual network, which is displayed in the query builder.\n     */\n\tself.onSelectClick = function(params, network){\n\t\tif(params.nodes.length > 0){\n\t\t\tself.selectedNode = self.nodeIDStore[params.nodes[0]];\n\t\t}\n\t\telse {\n\t\t\tself.selectedNode = undefined;\n\t\t}\n\n\t\tif(params.edges.length > 0){\n\t\t\tself.selectedRelation = self.relationshipIDStore[params.edges[0]];\n\t\t}\n\t\telse {\n\t\t\tself.selectedRelation = undefined;\n\t\t}\n\n\t\t$scope.$apply();\n\t}\n\n\n   /********\n   Dilaog in vis.js\n   *********/\n   /**\n    *\n    * This method checks whether the brackets of the filter attributes were set correctly.\n    * e.g. There must be as many opening brackets as closing brackets. One cannot start with a closing\n    * bracket.\n    * \n    * @param {Object} filterAttributes - The filter attributes.\n    * @return {string} Returns a list of wrong attributes (attributes where the brackets were not set correctly). \n    */\n   self.checkBrackets = function(filterAttributes){\n\t\tvar wrongAttributesNames = \"\";\n\t\tif(filterAttributes != undefined){\n\n\t   \t\tfor (var i = 0; i < filterAttributes.length; i++) {\t\n\n\t\t\t\tvar bracketCount = 0;\n\n\t\t\t\tif(filterAttributes[i].filters != undefined){\n\t\t\t\t\tfor (var k = 0; k < filterAttributes[i].filters.length; k++) {\n\t\t    \t\t\tif(filterAttributes[i].filters[k].isBracketOpen){\n\t\t    \t\t\t\tbracketCount = bracketCount +1;\n\t\t    \t\t\t}\n\t\t\t\t\t\tif(filterAttributes[i].filters[k].isBracketClosed){\n\t\t    \t\t\t\tbracketCount = bracketCount - 1;\n\t\t    \t\t\t}\n\n\t\t    \t\t\tif(bracketCount < 0){\n\t\t    \t\t\t\tbreak;\n\t\t    \t\t\t}\n\t\t    \t\t}\t\n\t\t\t\t}   \n\n\t\t\t\tif(bracketCount != 0){\n\t\t\t\t\tif(wrongAttributesNames != \"\"){\n\t\t\t\t\t\twrongAttributesNames = wrongAttributesNames + \", \";\n\t\t\t\t\t}\n\t\t\t\t\twrongAttributesNames  = wrongAttributesNames + filterAttributes[i].attributeName;\n\t\t\t\t} \t\t\n\t\t\t}\n\t    }\n\t    return wrongAttributesNames;\n   }\n\n      /**\n     * This method opens a new node dialog.\n     * In order to find the right node, it uses the id provided by vis.js.\n     * With this id the actual node can by found based on the self.nodeIDStore.\n     *\n     * @param {Object} params - The parameters from the vis.js click event. Further information: http://visjs.org/docs/network/\n     * @param {Object} network - The actual network, which is displayed in the query builder.\n     */\n    self.openNodeDialog = function(params, network){\n    \tvar $network = network;\n    \tvar params = params;\n    \tvar node = self.nodeIDStore[params[\"nodes\"][0]];\n\n    \tvar dialog = ngDialog.open({ template: 'querybuilder/nodeDialogTemplate.html',\n        \t\t\t\tclassName: 'ngdialog-theme-default custom-width',\n        \t\t\t\tcontroller: 'queryBuilderNodeDialogCtrl',\n        \t\t\t\tcontrollerAs: 'ctrl',\n        \t\t\t\tdata: \n                        {\n                            \"node\": node,\n                            \"author\": self.query.author\n                        }\n                    });\n\n\n\t    dialog.closePromise.then(function (data) {\n\t    \t\n\t    \tvar wrongAttributesNames = self.checkBrackets(node.filterAttributes);\n\t    \t\n\t    \tif(wrongAttributesNames != \"\"){\n\t    \t\tvar $dataForDialog = {\n\t\t\t\t\t\"head\":\"Error on closing\",\n\t\t\t\t\t\"content\":\"Wrong brackes in filter: \" + wrongAttributesNames\n\t\t\t\t};\n\n\t\t\t\tvar infoClosePromis = function(data){\n\t\t\t\t\tself.openNodeDialog(params, $network);\n\t\t\t\t}\n\t\t\t\tself.showInfoDialog($dataForDialog, infoClosePromis);\n\t    \t\t\n\t    \t}\n\t    \tself.onQueryChanged();\n\t\t\tself.transfersToGraph($network);\n\t\t\t \n\t\t});\n    };\n\n     /**\n     * This method opens a new relationship dialog.\n     * In order to find the right relationship, it uses the id provided by vis.js.\n     * With this id the actual relationship can by found based on the self.relationshipIDStore.\n     *\n     * @param {Object} params - The parameters from the vis.js click event. Further information: http://visjs.org/docs/network/\n     * @param {Object} network - The actual network, which is displayed in the query builder.\n     */\n    self.openEdgeDialog = function(params, network){\n    \t\t var edgeId =params[\"edges\"][0];\n    \t\t var relationship =  self.relationshipIDStore[edgeId];\n    \t\t var params = params;\n    \t\t var $network = network;\n\n\t         var dialog = ngDialog.open({ template: 'querybuilder/relationshipDialogTemplate.html',\n\t        \t\t\t\tclassName: 'ngdialog-theme-default custom-width',\n\t        \t\t\t\tcontroller: 'queryBuilderRelationshipDialogCtrl',\n\t        \t\t\t\tcontrollerAs: 'ctrl',\n\t        \t\t\t\tdata:\n                            {\n                                \"relationship\": relationship,\n                                \"author\": self.query.author\n                            }\n                        });\n\n\n\t        dialog.closePromise.then(function (data) {\n\t\t\t    \n\t\t    \tvar wrongAttributesNames = self.checkBrackets(relationship.filterAttributes);\n\t\t    \t\n\t\t    \tif(wrongAttributesNames != \"\"){\n\t\t    \t\tvar $dataForDialog = {\n\t\t\t\t\t\t\"head\":\"Error on closing\",\n\t\t\t\t\t\t\"content\":\"Wrong brackes in filter: \" + wrongAttributesNames\n\t\t\t\t\t};\n\n\t\t\t\t\tvar infoClosePromis = function(data){\n\t\t\t\t\t\tself.openEdgeDialog(params, $network);\n\t\t\t\t\t}\n\t\t\t\t\tself.showInfoDialog($dataForDialog, infoClosePromis);\n\t\t    \t\t\n\t\t    \t}\n\t\t    \tself.onQueryChanged();\n\t\t\t\tself.transfersToGraph($network);\n\t\t\t});\n    }\n\n\t/**\n\t * Loads the old query from $rootScope if it is available.\n\t * If there is no old query available then load the nodes to initialize the query.\n\t */\n\tif($rootScope.queryBuilderOldQuery !== undefined){\n        self.loadQueryLogic($rootScope.queryBuilderOldQuery);\n    }\n    else{\n    \t$requests.getNodes(self.getNodesCB);\n    }\n\n\n     /**\n      * This property holdes if a user is allowed to edit the query.\n      * @type {boolean}  if the user is allowed to edit.\n      */ \n      self.hasPermissions = (self.query.author === $rootScope.principal.username);\n\n\n}]);",
    "static": true,
    "longname": "App/querybuilder/querybuilder.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 15,
    "kind": "file",
    "name": "App/querybuilder/relationshipDialogTemplate.js",
    "content": "'use strict';\n\nangular.module('queryBuilder.querybuilderrelationshipdialog', ['ngRoute'])\n\n\n/**\n   * The controller which handles the relationship configuration.\n   * It will be opened when a relationship was clicked.\n   * \n   * In general, this controller helps to add or remove return attributes,\n   * orderby attributes and filter attributes.\n   * Every certain key (attribute) of a node can have a return, orderby or \n   * filter attribute. If such a attribute is required the json will be \n   * added with the set method.\n   * The possible attributes are first loaded into the keys array.\n   * \n   * @version 1.0.0\n   */\n.controller('queryBuilderRelationshipDialogCtrl', ['$requests', '$scope', '$rootScope', 'ngDialog',\n    function($requests, $scope, $rootScope, ngDialog) {\n        var self = this;\n\n        \n         /**\n         * The property contains all informations about the relationship.\n         * This information is handed in from the query builder.\n         * @type {Object}\n         */ \n        self.relationship = $scope.ngDialogData.relationship;\n\n         /**\n         * The property contains the author of the query in which the\n         * relationship is contained.\n         * This information is handed in from the query builder.\n         * @type {Object}\n         */ \n        self.author = $scope.ngDialogData.author;\n\n        /**\n         * The name of the relation.\n         * @type {Object}\n         */ \n        self.name = self.relationship['relationshipType'];\n         /**\n         * The direction of the relationship. \n         * A relation can be either ingoing or outgoing.\n         * @type {Object}\n         */ \n        self.direction = self.relationship['direction'];\n         /**\n         * Checks whether the certain property is optional or not.\n         * \n         * @return {boolean} Returns optional property.\n         */ \n        self.isOptionalChecked = function(){\n        \treturn self.relationship['optional'];\n        }\n         /**\n         * Sets the specific optional property.\n         *\n         * @param {boolean} value - The new value of the optional property.\n         */ \n        self.setOptionalChecked = function(value){\n        \treturn self.relationship['optional'] = value;\n        }\n\n         /**\n        * This method opens an info dialog. It displays a certain data (head and content)\n        * given in the $data. Furthermore, a callback can be specified, when the dialg is closed.\n        *\n        * @param {!Object} $data - the head an the content for the info dialog.\n        * @param {?function} infoClosePromis - The function which should be called when the dialog is closed.\n        */\n        self.showInfoDialog = function($data, infoClosePromis){\n            var dialog = ngDialog.open({ template: 'querybuilder/infoDialog.html',\n                            className: 'ngdialog-theme-default custom-width',\n                            controller: 'querybuilderInfoDialogCtrl',\n                            controllerAs: 'ctrl',\n                            data:$data\n                     });\n            if(infoClosePromis !== undefined){\n                dialog.closePromise.then(infoClosePromis);\n            }\n        }\n\n        /******************************\n        LOADING \n        /******************************/\n        /**\n        * The callback when the requested keys were loaded.\n        * The keys are all possible attributes where one can apply a filter.\n        *\n        * @param {boolean} $success - true when there are no errors.\n        * @param {Object} $data - the requested data (In this case the keys).\n        * @param {number} $status - the actual server status.\n        */\n        self.getRelationshipKeyCB = function($success, $data, $status){\n            self.hasError = !$success;\n            if($success){\n                self.keys = $data; \n            }\n        };\n         /**\n         * This method loads all keys.\n         * The keys are all possible attributes where one can apply a filter, set it as return attribue or\n         * order the results according to it.\n         */\n        $requests.getRelationshipKeys(self.relationship['relationshipType'], self.getRelationshipKeyCB);\n\n        /******************************\n        PROPETY SETTING\n        /******************************/\n        \n        //RETURN\n        /**\n        * This method searches for a certain return attribute with a certain the attribute name.\n        * \n        * @param {string} $key - The key of the return attribute. The key is the same as the attribute name.\n        * @return {Object} The given return attribute or undefined.\n        */\n        self.getReturnAttributes = function($key){\n            var returnAttribute = undefined;\n            for (var i = self.relationship['returnAttributes'].length - 1; i >= 0; i--) {\n                if(self.relationship['returnAttributes'][i]['attributeName'] === $key){\n                    returnAttribute = self.relationship['returnAttributes'][i];\n                    break;\n                }\n            }\n            return returnAttribute;\n        };\n\n        /**\n        * Checks whether a certain return attribute with a certain key (attribute name) exists or not.\n        *\n        * @param {string} $key - The return attribute key. The key is the same as the attribute name.\n        * @return {boolean} True if the attribute with the given key exists, otherwise false.\n        */\n        self.isReturnAttributesChecked = function($key){\n            if(self.getReturnAttributes($key) === undefined){\n                return false;\n            }\n            return true;\n        };\n        /**\n        * Checks whether a certain return attribute with a certain key exists or not.\n        * If it exists it removes the return attribute, if not it creates a return attribute with \n        * the given key. \n        * Every call toggles a certain return attribute with a certain key.\n        * This is necessary because only the keys which should be returned should have an \n        * entry in the returnAttributes array. For one key (attribute name)\n        * there can be only one return attribute.\n        *\n        * @param {string} $key - The key of the property which should be added or deleted.\n        */\n        self.setReturnAttributes = function($key){\n            var returnAttribute = self.getReturnAttributes($key);\n            if(returnAttribute !== undefined){\n                //Deletes a return attribute\n                var index = self.relationship['returnAttributes'].indexOf(returnAttribute);\n                self.relationship['returnAttributes'].splice(index, 1); \n\n                if(self.getOrderByAttributes($key) !== undefined){\n                    self.setOrderByAttributes($key);\n                }\n            }\n            else\n            {\n                //Adds an return attribute\n                self.relationship['returnAttributes'].push({\n                    \"attributeName\":$key,\n                    \"alias\":\"\",\n                    \"aggregation\" : \"NONE\"\n                });\n            }\n        };\n\n        /**\n        * This method sets a property of a certain return attribute identified by \n        * the key (attribute name).\n        *\n        * @param {string} $key - The key of the return attribute. The key is the same as the attribute name.\n        * @param {string} $type - The property which should be set. \n        * @param {Object} $value - The characteristic of the property ($type).\n        */\n        self.setReturnAttributesValue = function($key, $type, $value){\n            var returnAttribute = self.getReturnAttributes($key);\n            if(returnAttribute !== undefined){\n                returnAttribute[$type] = $value;\n            }\n            console.log(returnAttribute);\n        };\n\n        //ORDER BY \n        /**\n        * This method searches for a certain orderby attribute with a certain attribute name (key).\n        *\n        * @param {string} $key - The key of the orderby attribute. The key is the same as the attribute name.\n        * @return {Object} The given orderby attribute or undefined.\n        */\n        self.getOrderByAttributes = function($key){\n            var orderByAttribute = undefined;\n            for (var i = self.relationship['orderByAttributes'].length - 1; i >= 0; i--) {\n                if(self.relationship['orderByAttributes'][i]['attributeName'] === $key){\n                    orderByAttribute = self.relationship['orderByAttributes'][i];\n                    break;\n                }\n            }\n            return orderByAttribute;\n        };\n\n        /**\n        * Checks whether a certain orberby attribute with a certain key (attribute name) exists or not.\n        *\n        * @param {string} $key - The orberby attribute key. The key is the same as the attribute name.\n        * @return {boolean} True if the attribute with the given key exists, otherwise false.\n        */\n        self.isOrderByAttributesChecked = function($key){\n            if(self.getOrderByAttributes($key) === undefined){\n                return false;\n            }\n            return true;\n        };\n     \n        /**\n        * Checks whether a certain orberby attribute with a certain key exists or not.\n        * If it exists it removes the orberby attribute, if not it creates a orberby attribute with \n        * the given key. \n        * Every call toggles a certain orberby attribute with a certain key.\n        * This is necessary because only the keys which should be returned should have an \n        * entry in the returnAttributes array. For one key (attribute name)\n        * there can be only one orberby attribute.\n        *\n        * @param {string} $key - The key of the property which should be added or deleted.\n        */\n        self.setOrderByAttributes = function($key){\n            var orderByAttribute = self.getOrderByAttributes($key);\n            //Toggle attribute\n            if(orderByAttribute !== undefined){\n                //Deletes an return attribute\n                var index = self.relationship['orderByAttributes'].indexOf(orderByAttribute);\n                self.relationship['orderByAttributes'].splice(index, 1);    \n            }\n            else\n            {\n                if(self.getReturnAttributes($key) === undefined){\n                    self.setReturnAttributes($key);\n                }\n                //Adds an return attribute\n                self.relationship['orderByAttributes'].push({\n                    \"attributeName\":$key,\n                    \"id\": 1,\n                    \"direction\": \"asc\"\n                });\n            }\n        };\n\n        /**\n        * This method sets a property of a certain orderby attribute identified by \n        * the key (attribute name).\n        *\n        * @param {string} $key - The key of the orderby attribute. The key is the same as the attribute name.\n        * @param {string} $type - The property which should be set. \n        * @param {Object} $value - The characteristic of the property ($type).\n        */\n        self.setOrderByAttributesValue = function($key, $type, $value){\n            var orderByAttribute = self.getOrderByAttributes($key);\n            if(orderByAttribute !== undefined){\n                orderByAttribute[$type] = $value;\n            }\n        };\n        \n        //FILTER ATTRIBUTES\n        /**\n        * This method searches for a certain filter attribute with a certain attribute name (key).\n        *\n        * @param {string} $key - The key of the filter attribute. The key is the same as the attribute name.\n        * @return {Object} The given filter attribute or undefined.\n        */\n        self.getFilterAttributes = function($key){\n            var returnFilterAttribute = undefined;\n            for (var i = self.relationship['filterAttributes'].length - 1; i >= 0; i--) {\n                if(self.relationship['filterAttributes'][i]['attributeName'] === $key){\n                    returnFilterAttribute = self.relationship['filterAttributes'][i];\n                    break;\n                }\n            }\n            return returnFilterAttribute;\n        };\n\n        /**\n        * Checks whether a certain filter attribute with a certain key (attribute name) exists or not.\n        *\n        * @param {string} $key - The filter attribute key. The key is the same as the attribute name.\n        * @return {boolean} True if the attribute with the given key exists, otherwise false.\n        */\n        self.isFilterAttributesChecked = function($key){\n            if(self.getFilterAttributes($key) === undefined){\n                return false;\n            }\n            return true;\n        };\n\n        /**\n        * Checks whether a certain filter attribute with a certain key exists or not.\n        * If it exists it removes the filter attribute, if not it creates a filter attribute with \n        * the given key. \n        * Every call toggles a certain filter attribute with a certain key.\n        * This is necessary because only the keys which should be returned should have an \n        * entry in the returnAttributes array. For one key (attribute name)\n        * there can be only one filter attribute.\n        *\n        * Because a filter attribute can also have relations between each other, this \n        * method handles the relations by setting the logic attribute. If two attributes are\n        * combined by this logic, the first holds the logic.\n        * \n        * If a new attribute is added, \n        * this method also adds the logic to the previous attribute. \n        * If the last attribute is removed the logic\n        * of the attribute before it is also removed.\n        * \n        * This works because the filter attributes are ordered alphabetically.\n        * \n        * @param {string} $key - The key of the property which should be added or deleted.\n        */\n        self.setFilterAttributes = function($key){\n            var filterAttribute = self.getFilterAttributes($key);\n            if(filterAttribute !== undefined){\n                //lösche return Attribute\n                //lösche return Attribute\n                var index = self.relationship['filterAttributes'].indexOf(filterAttribute);\n\n                if(self.relationship['filterAttributes'].length - 1 === index && index !== 0){\n                    self.relationship['filterAttributes'][index - 1].logic = \"\";\n                }\n\n                self.relationship['filterAttributes'].splice(index, 1); \n            }\n            else\n            {\n                var newFilterAttribute = {\n                        \"attributeName\":$key,\n                        \"logic\":\"\",\n                        \"filters\": [\n                            {\n                                \"id\":0,         //for Frontend\n                                \"type\":\"string\",         //int, string...\n                                \"filterType\": \"=\",  // \"in\",\"like\",\"=\",\">\"\n                                \"value\":\"\", \n                                \"changeable\":false,\n                                \"isBracketOpen\": false,\n                                \"isBracketClosed\": false,\n                                \"logic\":\"\"           //“AND/OR”\n                            }\n                        ]   //The parameters list can be changed. (new parameters added or removed)\n                };\n                //add an attribute\n                self.relationship['filterAttributes'].push(\n                    newFilterAttribute\n                );\n                 //sort alphabetically\n                self.relationship['filterAttributes'] = self.relationship['filterAttributes'].sort(function(x, y) {\n                    if (x['attributeName'] == y['attributeName']) return 0;\n                    else if (x['attributeName'] < y['attributeName']) return -1;\n                    else return 1;\n                });\n                //add logic to index +1 and index - 1 if not available\n                var index = self.relationship['filterAttributes'].indexOf(newFilterAttribute);\n\n                if(index > 0){\n                    if(self.relationship['filterAttributes'][index - 1].logic === \"\" ||\n                        self.relationship['filterAttributes'][index - 1].logic === undefined){\n                        self.relationship['filterAttributes'][index - 1].logic = \"AND\";\n                    };\n                }\n                if(self.relationship['filterAttributes'].length - 1 > index  ){\n                    self.relationship['filterAttributes'][index].logic = \"AND\";\n                }\n                console.log(self.relationship);\n            }\n        };\n\n        /**\n        * This method sets a property of a certain filter attribute identified by \n        * the key (attribute name).\n        *\n        * @param {string} $key - The key of the filter attribute. The key is the same as the attribute name.\n        * @param {string} $type - The property which should be set. \n        * @param {Object} $value - The characteristic of the property ($type).\n        */\n        self.setFilterAttributesValue = function($key, $type, $value){\n            var filterAttributes = self.getFilterAttributes($key);\n\n            if(filterAttributes != undefined\n                && filterAttributes[$type] !== $value){\n                filterAttributes[$type] = $value;\n            }\n\n            console.log(\"Set key: \" + $key + \", type: \" + $type  + \", value: \" + $value );\n        };\n\n         /**\n        * A filter attribute contains multiple (at least one) filter. Each filter is \n        * identified by an id. \n        * This method searches for a certain filter identified by an id\n        * in a certain filter attribute identified a certain attribute name (key).\n        *\n        * @param {string} $key - The key of the filter attribute. The key is the same as the attribute name.\n        * @param {string} $id - The id of the specific filter. \n        * @return {Object} The given filter attribute or undefined.\n        */\n        self.getFilterAttributesFilter = function($key, $id){\n            var filterAttributes = self.getFilterAttributes($key);\n\n            if(filterAttributes !== undefined && \n                filterAttributes.filters !== undefined){\n                for (var i = filterAttributes.filters.length - 1; i >= 0; i--) {\n                    if(filterAttributes.filters[i].id === $id){\n                        return filterAttributes.filters[i]; \n                    }\n                }\n            }\n\n            return undefined;\n        }\n\n        /**\n        * This method sets a property of a certain filter identified by an id in\n        * a certain filter attribute identified by an attribute name (key).\n        *\n        * @param {string} $key - The key of the filter attribute. The key is the same as the attribute name.\n        * @param {string} $id - The id of the specific filter. \n        * @param {string} $type - The property which should be set. \n        * @param {Object} $value - The characteristic of the property ($type).\n        */\n        self.setFilterAttributesFilterValue = function($key, $id, $type, $value){\n            var filterAttributesFilter = self.getFilterAttributesFilter($key, $id);\n\n            if(filterAttributesFilter != undefined && \n                filterAttributesFilter[$type] !== $value){\n                filterAttributesFilter[$type] = $value;\n                if($type === 'type'){\n                    filterAttributesFilter['value'] = undefined; \n                }\n            }\n\n            console.log(\"Set key: \" + $key + \", type: \" + $type + \n                            + \", id: \" + $id + \", value: \" + $value );\n        };\n\n        /**\n        * This method adds a filter to a filter attribute.\n        * The new filter will have a unique id.\n        * This method also sorts the filter attributes by the id.\n        * The filter attributes were combined with a certain logic (AND, OR) within  \n        * a certain filter attributes. This method initializes also the logic.\n        *\n        * @param {string} $key - The key of the filter attribute in which the filter should be added.\n        */\n        self.addFilterAttributesFilter = function($key){\n\n            var filterAttributes = self.getFilterAttributes($key);\n\n            if( filterAttributes !== undefined &&\n                filterAttributes !== null &&\n                filterAttributes.filters !== undefined &&\n                filterAttributes.filters !== null ){\n                //sort filters ascending\n                filterAttributes.filters.sort(function(x, y) {\n                    if (x['id'] == y['id']) return 0;\n                    else if (parseInt(x['id']) < parseInt(y['id'])) return -1;\n                    else return 1;\n                });\n                //there must be at least one filter in the filters array\n                //otherwise: invalid state\n\n                if(filterAttributes.filters.length > 0){\n                    filterAttributes.filters[filterAttributes.filters.length - 1].logic = \"AND\";\n                }\n\n                var id = filterAttributes.filters[filterAttributes.filters.length - 1].id;\n                id = id +1;\n                filterAttributes.filters.push(\n                {\n                    \"id\":id,            //for Frontend\n                    \"type\":\"string\",    //int, string...\n                    \"filterType\": \"=\",  //like \"in\",\"like\",\"=\",\">\"\n                    \"value\":\"\", \n                    \"changeable\":false,\n                    \"isBracketOpen\": false,\n                    \"isBracketClosed\": false,\n                    \"logic\":\"\"          //“AND/OR”\n                });\n            }\n        }\n        \n        /**\n        * This method removes a filter identified by an id of a filter attribute\n        * identified by the attribute name (key).\n        *\n        * The filter attributes werew combined with a certain logic (AND, OR). \n        * If required, this method deletes this logic too.\n        *\n        * @param {string} $key - The key of the filter attribute in which the filter should be removed.\n        * @param {string} $id - The id of the specific filter which should be removed. \n        */\n        self.deleteFilterAttributesFilter = function($key, $id){\n            var filterAttributes = self.getFilterAttributes($key);\n\n            if(filterAttributes !== undefined){\n                //There must be at least one filter in the array\n                if(filterAttributes.filters != undefined &&\n                    filterAttributes.filters.length > 1){\n                    //Delete filter\n                    var filterAttributesFilter = self.getFilterAttributesFilter($key, $id);\n                    if(filterAttributesFilter != undefined){\n                        var index = filterAttributes.filters.indexOf(filterAttributesFilter);\n                        if(filterAttributes.filters.length - 1 === index && index !== 0){\n                            filterAttributes.filters[index - 1].logic = \"\";\n                        }\n                        \n                        filterAttributes.filters.splice(index, 1);  \n                    }\n                }   \n            }\n        }\n\n       /**\n         * This function checks wheather a user has the  \n         * permission to edit the items or not.\n         *\n         * @param {string} $attributeType - The type of the attribute -> \"filter\", \"return\", \"orderby\"\n         * @param {string} $key - The key of the attribute for which the permissions should be cheked. \n         * @param {Object} $additionalInfo - Additional informations.\n         * @return {boolean} Returns optional property.\n         */ \n        self.hasPermissions = function($attributeType, $key, $additionalInfo){\n            if(self.author === $rootScope.principal.username){\n                //the author can do everything\n                return true;\n            }\n            else {\n                //permission is only granted to filter attributes\n                if($attributeType === \"filter\" && $additionalInfo != undefined &&\n                    $additionalInfo.type != undefined && $additionalInfo.id != undefined &&\n                    $additionalInfo.type != \"changeable\"){\n\n                    var filterAttributesFilter = self.getFilterAttributesFilter($key, $additionalInfo.id);\n                    if(filterAttributesFilter.changeable){\n                        return true;\n                    }\n                    return false;\n                    \n                }\n                return false;\n            }\n        }\n\t\n}]);\n",
    "static": true,
    "longname": "App/querybuilder/relationshipDialogTemplate.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 16,
    "kind": "file",
    "name": "App/register/register.js",
    "content": "(function () {\r\n    'use strict';\r\n\r\n    angular\r\n        .module('queryBuilder.register', [])\r\n        .controller('RegisterController', RegisterController);\r\n\r\n    RegisterController.$inject = ['$http', '$requests', '$serverRestLocation', '$location', '$rootScope'];\r\n    function RegisterController($http, $requests, $serverRestLocation, $location, $rootScope) {\r\n        var self = this;\r\n\r\n        self.register = register;\r\n\r\n        /**\r\n\t    * Executes the registration of a new user and checks all fields of the form are correctly filled in\r\n\t    */\r\n        function register() {\r\n             self.text = \"\";\r\n            if(!validateEmail(self.user.email)){\r\n                self.text += \"Bitte geben Sie eine korrekte Email Adresse ein. \\n\";\r\n            }\r\n            if(self.user.password !=  self.user.passwordRepeat){\r\n                self.text += \"Das Passwort und das wiederholte Passwort müssen übereinstimmen. \\n\";\r\n            }\r\n            if(self.text != \"\"){\r\n                $(\"#registerErrorModal\").modal();\r\n            }\r\n            else {\r\n                $requests.register(self.user, self.callback);\r\n            }\r\n        }\r\n\r\n        /**\r\n\t    * Validates that the filled in email is a valid email address\r\n\t    */\r\n        function validateEmail(email) {\r\n            var re =  /^(([^<>()[\\]\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@(([^<>()[\\]\\.,;:\\s@\\\"]+\\.)+[^<>()[\\]\\.,;:\\s@\\\"]{2,})$/i;\r\n            return re.test(email);\r\n        }\r\n\r\n        /**\r\n\t * Callback from register call. If query was successful go to login page.\r\n\t * Otherwise print error.\r\n\t *\r\n\t * @param {boolean} $success - true when there are no errors.\r\n\t * @param {Object} $data - the requested data.\r\n     * @param {number} $status - the actual server status.\r\n\t */\r\n        self.callback = function($success, $data, $status) {\r\n\t\tself.hasError = !$success;\r\n\t\tif($success){\r\n\t\t\t$location.path(\"/login\");\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tself.error = $data;\r\n\t\t}\r\n\t}\r\n    }\r\n\r\n\r\n})();",
    "static": true,
    "longname": "App/register/register.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 17,
    "kind": "file",
    "name": "App/services.js",
    "content": "angular.module('queryBuilder.services', ['ngCookies'])\n/**\n   * This service provides the actual server location.\n   * \n   * @version 1.0.0\n   */\n.service('$serverRestLocation',  function() {\n    var serverRestLocation = \"http://localhost:8080\";\n\n    this.getValue = function() {\n        return serverRestLocation;\n    };\n})\n/**\n   * This servicesprovides all possible requests to the application.\n   * \n   * @version 1.0.0\n   */\n.service('$requests', ['$serverRestLocation', '$http', function($serverRestLocation, $http) {\n    //execute query\n    this.getResultFromQuery = function($query, $params, $callback) {\n        $http({\n            method : 'POST',\n            url : $serverRestLocation.getValue() + '/expertqueries/execute', \n            headers: {  'Content-Type':'application/json'},\n            data: { \n              \"query\" : $query,\n              \"parameter\" :  $params }\n        })\n        .success(function(data, status) {\n            console.log(data);\n            if($callback !== undefined){\n            $callback(true, data, status);\n            }\n        })\n        .error(function(data, status) {\n            console.log(data);\n            if($callback !== undefined){\n           $callback(false, data, status);\n            }\n        });\n    };\n\n    /**\n     * Execute Query with Querybuilder.\n     * It should return the table or an error message.\n     * \n     * @param {Object} $query - the query which should be executed.\n     * @param {function($success: number, $data: string, $status: number)} $callback - \n     *            This function is called after the execution in order to send data and the status t\n     *              to the calling function.\n     */\n    this.getResultFromQueryQueryBuilder = function($query, $callback) {\n        $http({\n            method : 'POST',\n            url : $serverRestLocation.getValue() + '/queryBuilder/execute', \n            headers: {  'Content-Type':'application/json'},\n            data:      $query\n        })\n        .success(function(data, status) {\n            console.log(data);\n            if($callback !== undefined){\n            $callback(true, data, status);\n            }\n        })\n        .error(function(data, status) {\n            console.log(data);\n            if($callback !== undefined){\n           $callback(false, data, status);\n            }\n        });\n    };\n\n     /**\n     * This method should return the query in cypher.\n     * It can be used to convert a query in the querybuilder\n     * from the internal representation to cypher.\n     *\n     * @param {Object} $query - the query which should be converted.\n     * @param {function($success: number, $data: string, $status: number)} $callback - \n     *            This function is called after the execution in order to send data and the status \n     *              to the calling function.\n     */\n    this.getQueryFromQueryQueryBuilder = function($query, $callback) {\n        $http({\n            method : 'POST',\n            url : $serverRestLocation.getValue() + '/queryBuilder/queryString', \n            headers: {  'Content-Type':'application/json'},\n            data:      $query\n        })\n        .success(function(data, status) {\n            console.log(data);\n            if($callback !== undefined){\n            $callback(true, data, status);\n            }\n        })\n        .error(function(data, status) {\n            console.log(data);\n            if($callback !== undefined){\n           $callback(false, data, status);\n            }\n        });\n    };\n\n\n\n    this.register = function($user,  $callback) {  \n        $http({\n            method : 'POST',\n            url : $serverRestLocation.getValue()+ '/user/', \n            headers: {  'Content-Type':'application/json',\n        },\n            data: { \n                email : $user.email,\n                password : $user.password,\n                firstName : $user.firstName,\n                lastName : $user.lastName}\n        })\n        .success(function(data, status) {\n            $callback(true, data, status); \n        })\n        .error(function(data, status) {\n            $callback(false, data, status);\n        });\n        };\n\n\n    /**\n     * This method should return all nodes in the database.\n     *\n     * @param {function($success: number, $data: string, $status: number)} $callback - \n     *            This function is called after the execution in order to send data and the status \n     *              to the calling function.\n     */\n    this.getNodes = function($callback) {\n        $http({\n            method : 'GET',\n            url : $serverRestLocation.getValue() + '/nodetypes', \n            headers: { \n                    'Content-Type':'application/json'\n            }\n        })\n        .success(function(data, status) {\n            $callback(true, data, status); \n        })\n        .error(function(data, status) {\n            $callback(false, data, status);\n        });\n    };\n\n    /**\n     * This method should return all keys (attribute names) for a certain node (as label)\n     * from the database.\n     *\n     * @param {string} $label -  The name of the node.\n     * @param {function($success: number, $data: string, $status: number)} $callback - \n     *            This function is called after the execution in order to send data and the status \n     *              to the calling function.\n     */\n    this.getKeys = function($label, $callback) {\n        $http({\n            method : 'GET',\n            url : $serverRestLocation.getValue() + '/nodetypes/' + $label + '/keys', \n            headers: { \n                    'Content-Type':'application/json'\n            }\n        })\n        .success(function(data, status) {\n            $callback(true, data, status); \n        })\n        .error(function(data, status) {\n            $callback(false, data, status);\n        });\n    };\n\n     /**\n     * This method should return all keys (attribute names) for a certain relationship (as label)\n     * from the database.\n     *\n     * @param {string} $label -  The name of the relationship.\n     * @param {function($success: number, $data: string, $status: number)} $callback - \n     *            This function is called after the execution in order to send data and the status \n     *              to the calling function.\n     */\n    this.getRelationshipKeys = function($label, $callback) {\n        $http({\n            method : 'GET',\n            url : $serverRestLocation.getValue() + '/relationshiptypes/' + $label + '/keys', \n            headers: { \n                    'Content-Type':'application/json'\n            }\n        })\n        .success(function(data, status) {\n            $callback(true, data, status); \n        })\n        .error(function(data, status) {\n            $callback(false, data, status);\n        });\n    };\n    \n      /**\n     * This method returns all relationships with their corresponding nodes for \n     * a certain node (as $label).\n     *\n     * @param {string} $label -  The name of the node.\n     * @param {function($success: number, $data: string, $status: number)} $callback - \n     *            This function is called after the execution in order to send data and the status \n     *              to the calling function.\n     */\n    this.getRelationsWithNodes = function($label, $callback) {\n        $http({\n            method : 'GET',\n            url : $serverRestLocation.getValue()+ '/nodetypes/'+ $label + '/relations/', \n            headers: { \n                    'Content-Type':'application/json'\n            }\n        })\n        .success(function(data, status) {\n            $callback(true, data, status); \n        })\n        .error(function(data, status) {\n            $callback(false, data, status);\n        });\n    };\n\n    /**\n     * This method saves a query from the expert mode. \n     * Only new queries can be saved.\n     *\n     * @param {String} $query - the query which should be saved.\n     * @param {Array} $params - the parameters for the query.\n     * @param {String} $name - the entered name for the query.\n     * @param {String} $description - the entered description for the query.\n     * @param {String} $category - the selected category for the query.\n     * @param {function($success: number, $data: string, $status: number)} $callback - \n     *            This function is called after the execution in order to send data and the status \n     *              to the calling function.\n     */\n    this.saveQuery = function($query, $params, $name, $description, $category, $callback) {\n        console.log($category);\n        $http({\n            method : 'POST',\n            url : $serverRestLocation.getValue() + '/expertqueries', \n            headers: {  'Content-Type':'application/json'},\n            data: { \n              \"query\" : $query,\n              \"parameter\" :  $params,\n                \"name\" : $name,\n                \"description\" : $description,\n                \"category\" : $category }\n        })\n        .success(function(data, status) {\n            console.log(data);\n            if($callback !== undefined){\n            $callback(true, data, status);\n            }\n        })\n        .error(function(data, status) {\n            console.log(data);\n            if($callback !== undefined){\n           $callback(false, data, status);\n            }\n        });\n    };\n\n    /**\n     * This method saves a query from the query builder. \n     * Only new queries can be saved. If an existing should be saved an\n     * update needs to be done.\n     *\n     * @param {Object} $query - the query which should be saved.\n     * @param {function($success: number, $data: string, $status: number)} $callback - \n     *            This function is called after the execution in order to send data and the status \n     *              to the calling function.\n     */\n    this.saveQueryInBuilder = function($query, $callback) {\n        $http({\n            method : 'POST',\n            url : $serverRestLocation.getValue() + '/queryBuilder', \n            headers: {  'Content-Type':'application/json'},\n            data: $query\n        })\n        .success(function(data, status) {\n            if($callback !== undefined){\n                $callback(true, data, status);\n            }\n        })\n        .error(function(data, status) {\n            if($callback !== undefined){\n                 $callback(false, data, status);\n            }\n        });\n    };\n\n    /**\n     * This method updates a query from the query builder.\n     * Before one can do an update, the query must be saved first.\n     *\n     * @param {Object} $query - the query which should be updated.\n     * @param {function($success: number, $data: string, $status: number)} $callback - \n     *            This function is called after the execution in order to send data and the status \n     *              to the calling function.\n     */\n    this.updateQueryInBuilder = function($query, $id, $callback) {\n        $http({\n            method : 'PUT',\n            url : $serverRestLocation.getValue() + '/queryBuilder/' + $id, \n            headers: {  'Content-Type':'application/json'},\n            data: $query\n        })\n        .success(function(data, status) {\n            if($callback !== undefined){\n                $callback(true, data, status);\n            }\n        })\n        .error(function(data, status) {\n            if($callback !== undefined){\n                 $callback(false, data, status);\n            }\n        });\n    };\n    \n    \n    /**\n     * This method deletes a query from the expert mode. \n     *\n     * @param {String} $query - the query which should be deleted.\n     * @param {Array} $params - the parameters for the query.\n     * @param {String} $name - the entered name for the query.\n     * @param {String} $description - the entered description for the query.\n     * @param {String} $category - the selected category for the query.\n     * @param {function($success: number, $data: string, $status: number)} $callback - \n     *            This function is called after the execution in order to send data and the status \n     *              to the calling function.\n     */\n    this.deleteQuery = function($query, $params, $name, $description, $category, $callback) {\n        $http({\n            method : 'DELETE',\n            url : $serverRestLocation.getValue() + '/expertqueries/' + $name, \n            headers: {  'Content-Type':'application/json'},\n            data: { \n              \"query\" : $query,\n              \"parameter\" :  $params,\n                \"name\" : $name,\n                \"description\" : $description,\n                \"category\" : $category }\n        })\n        .success(function(data, status) {\n            console.log(data);\n            if($callback !== undefined){\n            $callback(true, data, status);\n            }\n        })\n        .error(function(data, status) {\n            console.log(data);\n            if($callback !== undefined){\n           $callback(false, data, status);\n            }\n        });\n    };    \n\n    /**\n     * This method deletes a query from the query builder.\n     * The query is referenced by the id.\n     *\n     * @param {number} $id - the id of the query which should be deleted.\n     * @param {function($success: number, $data: string, $status: number)} $callback - \n     *            This function is called after the execution in order to send data and the status \n     *              to the calling function.\n     */\n     this.deleteQueryInBuilder = function( $id, $callback) {\n       $http({\n            method : 'DELETE',\n            url : $serverRestLocation.getValue() + '/queryBuilder/' + $id, \n            headers: {  'Content-Type':'application/json'}\n        })\n        .success(function(data, status) {\n            if($callback !== undefined){\n                $callback(true, data, status);\n            }\n        })\n        .error(function(data, status) {\n            if($callback !== undefined){\n                 $callback(false, data, status);\n            }\n        });\n    };    \n    \n    /**\n     * This method load all queries. \n     *\n     * @param {function($success: number, $data: string, $status: number)} $callback - \n     *            This function is called after the execution in order to send data and the status \n     *              to the calling function.\n     */\n    this.loadAllQueries = function($callback) {\n        $http({\n            method : 'GET',\n            url : $serverRestLocation.getValue() + '/expertqueries', \n            headers: { \n                    'Content-Type':'application/json'\n            }\n        })\n        .success(function(data, status) {\n            $callback(true, data, status); \n        })\n        .error(function(data, status) {\n            $callback(false, data, status);\n        });\n    };\n\n    /**\n     * This method loads all saved query builder queries from the database .\n     *\n     * @param {function($success: number, $data: string, $status: number)} $callback - \n     *            This function is called after the execution in order to send data and the status \n     *              to the calling function.\n     */\n    this.loadAllQueriesInBuilder = function($callback) {\n        $http({\n            method : 'GET',\n            url : $serverRestLocation.getValue() + '/queryBuilder', \n            headers: { \n                    'Content-Type':'application/json'\n            }\n        })\n        .success(function(data, status) {\n            $callback(true, data, status); \n        })\n        .error(function(data, status) {\n            $callback(false, data, status);\n        });\n    };\n\n      /**\n     * This method filters the query builder queries which are saved in the database.\n     * One can filter the attributes by name, category and description.\n     *\n     * @param {function($success: number, $data: string, $status: number)} $callback - \n     *            This function is called after the execution in order to send data and the status \n     *              to the calling function.\n     */\n    this.loadSomeQueriesInBuilder = function($callback, $name, $category, $description) {\n        var filter = \"?\";\n        if($name !== null && $name !== undefined && $name !== \"\"){\n            filter = filter + \"name=\" + $name;\n        }\n        if($category !== null && $category !== undefined && $category !== \"\"){\n            if(filter !== \"?\"){\n                 filter = filter + \"&\";\n            }\n            filter = filter + \"category=\" + $category;\n        }\n        if($description !== null && $description !== undefined && $description !== \"\"){\n            if(filter !== \"?\"){\n                 filter = filter + \"&\";\n            }\n            filter = filter + \"description=\" + $description;\n        }\n        if(filter != \"?\"){\n            $http({\n                method : 'GET',\n                url : $serverRestLocation.getValue() + '/queryBuilder' + filter, \n                headers: { \n                        'Content-Type':'application/json'\n                }\n            })\n            .success(function(data, status) {\n                $callback(true, data, status); \n            })\n            .error(function(data, status) {\n                $callback(false, data, status);\n            });\n        }\n        else{\n            this.loadAllQueriesInBuilder($callback);\n        }\n       \n    };\n    \n    /**\n     * This method returns the query object for a specific query name. \n     *\n     * @param {String} $name - the entered name for the query.\n     * @param {function($success: number, $data: string, $status: number)} $callback - \n     *            This function is called after the execution in order to send data and the status \n     *              to the calling function.\n     */\n    this.getQueryByName = function($name, $callback) {\n        $http({\n            method : 'GET',\n            url : $serverRestLocation.getValue() + '/expertqueries/' + $name,\n            headers: { \n                    'Content-Type':'application/json'\n            },\n            data: { \n                \"name\" : $name\n              }\n        })\n        .success(function(data, status) {\n            $callback(true, data, status); \n        })\n        .error(function(data, status) {\n            $callback(false, data, status);\n        });\n    };\n    \n    /**\n     * This method returns all existing query names. \n     *\n     * @param {function($success: number, $data: string, $status: number)} $callback - \n     *            This function is called after the execution in order to send data and the status \n     *              to the calling function.\n     */\n    this.getAllAlertNames = function($callback) {\n        $http({\n            method : 'GET',\n            url : $serverRestLocation.getValue() + '/alerts', \n            headers: { \n                    'Content-Type':'application/json'\n            }\n        })\n        .success(function(data, status) {\n            $callback(true, data, status); \n        })\n        .error(function(data, status) {\n            $callback(false, data, status);\n        });\n    };\n    \n    /**\n     * This method creates a new alert. \n     *\n     * @param {String} $name - the entered name for the alert.\n     * @param {String} $selectedQuery - the selected query for the alert.\n     * @param {String} $type - the selected type for the alert.\n     * Examples: int, string,...\n     * @param {String} $filterType - the selected filter type for the alert.\n     * Examples: in, like,...\n     * @param {String} $email - the entered email address for the alert.\n     * @param {String} $value - the entered limit value for the alert.\n     * @param {function($success: number, $data: string, $status: number)} $callback - \n     *            This function is called after the execution in order to send data and the status \n     *              to the calling function.\n     */\n    this.addAlert = function($name, $selectedQuery, $type, $filterType,\n    \t\t$email, $value, $callback) {\n        $http({\n            method : 'POST',\n            url : $serverRestLocation.getValue() + '/alerts', \n            headers: {  'Content-Type':'application/json'},\n            data: { \n              \"name\" : $name,\n              \"query\" :  $selectedQuery,\n              \"type\" : $type,\n              \"filterType\" : $filterType,\n              \"value\" : $value,\n              \"email\" : $email }\n        })\n        .success(function(data, status) {\n            console.log(data);\n            if($callback !== undefined){\n            $callback(true, data, status);\n            }\n        })\n        .error(function(data, status) {\n            console.log(data);\n            if($callback !== undefined){\n           $callback(false, data, status);\n            }\n        });\n    };\n    \n    /**\n     * This method saves a existing alert. \n     *\n     * @param {String} $existingName - the name from overridden alert.\n     * @param {String} $name - the entered name for the alert.\n     * @param {String} $selectedQuery - the selected query for the alert.\n     * @param {String} $type - the selected type for the alert.\n     * Examples: int, string,...\n     * @param {String} $filterType - the selected filter type for the alert.\n     * Examples: in, like,...\n     * @param {String} $email - the entered email address for the alert.\n     * @param {String} $value - the entered limit value for the alert.\n     * @param {function($success: number, $data: string, $status: number)} $callback - \n     *            This function is called after the execution in order to send data and the status \n     *              to the calling function.\n     */\n    this.saveAlert = function($existingName, $name, $selectedQuery, $type, $filterType,\n    \t\t$email, $value, $callback) {\n        $http({\n            method : 'PUT',\n            url : $serverRestLocation.getValue() + '/alerts/' + $existingName, \n            headers: {  'Content-Type':'application/json'},\n            data: { \n              \"name\" : $name,\n              \"query\" :  $selectedQuery,\n              \"type\" : $type,\n              \"filterType\" : $filterType,\n              \"value\" : $value,\n              \"email\" : $email }\n        })\n        .success(function(data, status) {\n            console.log(data);\n            if($callback !== undefined){\n            $callback(true, data, status);\n            }\n        })\n        .error(function(data, status) {\n            console.log(data);\n            if($callback !== undefined){\n           $callback(false, data, status);\n            }\n        });\n    };\n    \n    /**\n     * This method deletes a existing alert. \n     *\n     * @param {String} $name - the entered name for the alert.\n     * @param {function($success: number, $data: string, $status: number)} $callback - \n     *            This function is called after the execution in order to send data and the status \n     *              to the calling function.\n     */\n    this.deleteAlert = function($name, $callback) {\n        $http({\n            method : 'DELETE',\n            url : $serverRestLocation.getValue() + '/alerts/' + $name, \n            headers: {  'Content-Type':'application/json'},\n            data: { \n                \"name\" : $name\n                }\n        })\n        .success(function(data, status) {\n            console.log(data);\n            if($callback !== undefined){\n            $callback(true, data, status);\n            }\n        })\n        .error(function(data, status) {\n            console.log(data);\n            if($callback !== undefined){\n           $callback(false, data, status);\n            }\n        });\n    };\n        \n    /**\n     * This method executes a existing alert. \n     *\n     * @param {String} $name - the entered name for the alert.\n     * @param {function($success: number, $data: string, $status: number)} $callback - \n     *            This function is called after the execution in order to send data and the status \n     *              to the calling function.\n     */\n    this.executeAlert = function($name, $callback) {\n        $http({\n            method : 'GET',\n            url : $serverRestLocation.getValue() + '/alerts/' + $name + '/execute', \n            headers: {  'Content-Type':'application/json'},\n            data: { \n                \"name\" : $name\n                }\n        })\n        .success(function(data, status) {\n            console.log(data);\n            if($callback !== undefined){\n            $callback(true, data, status);\n            }\n        })\n        .error(function(data, status) {\n            console.log(data);\n            if($callback !== undefined){\n           $callback(false, data, status);\n            }\n        });\n    };   \n\n    /**\n     * This method gets all existing categories.\n     *\n     * @param {function($success: number, $data: string, $status: number)} $callback - \n     *            This function is called after the execution in order to send data and the status \n     *              to the calling function.\n     */\n    this.getAllCategories = function($callback) {\n        $http({\n            method : 'GET',\n            url : $serverRestLocation.getValue() + '/categories', \n            headers: { \n                    'Content-Type':'application/json'\n            }\n        })\n        .success(function(data, status) {\n            $callback(true, data, status); \n        })\n        .error(function(data, status) {\n            $callback(false, data, status);\n        });\n    };   \n\n    /**\n     * This method adds a new category.\n     *\n     * @param {string} $name -  The name of the category.\n     * @param {string} $description -  The description of the category.\n     * @param {function($success: number, $data: string, $status: number)} $callback - \n     *            This function is called after the execution in order to send data and the status \n     *              to the calling function.\n     */\n    this.addCategory = function($name, $description, $callback) {\n        $http({\n            method : 'POST',\n            url : $serverRestLocation.getValue() + '/categories', \n            headers: {  'Content-Type':'application/json'},\n            data: { \n              \"name\" : $name,\n              \"description\" :  $description }\n        })\n        .success(function(data, status) {\n            console.log(data);\n            if($callback !== undefined){\n            $callback(true, data, status);\n            }\n        })\n        .error(function(data, status) {\n            console.log(data);\n            if($callback !== undefined){\n           $callback(false, data, status);\n            }\n        });\n    }; \n\n        \n    /**\n     * This method updates a existing category.\n     *\n     * @param {string} $id -  The id of the category which should be changed.\n     * @param {string} $name -  The name of the category.\n     * @param {string} $description -  The description of the category.\n     * @param {function($success: number, $data: string, $status: number)} $callback - \n     *            This function is called after the execution in order to send data and the status \n     *              to the calling function.\n     */\n    this.updateCategory = function($id, $name, $description, $callback) {\n        $http({\n            method : 'PUT',\n            url : $serverRestLocation.getValue() + '/categories/' + $id, \n            headers: {  'Content-Type':'application/json'},\n            data: { \n              \"name\" : $name,\n              \"description\" :  $description }\n        })\n        .success(function(data, status) {\n            console.log(data);\n            if($callback !== undefined){\n            $callback(true, data, status);\n            }\n        })\n        .error(function(data, status) {\n            console.log(data);\n            if($callback !== undefined){\n           $callback(false, data, status);\n            }\n        });\n    };\n\n    /**\n     * This method deletes a existing category.\n     *\n     * @param {string} $id -  The id of the category which should be deleted.\n     * @param {function($success: number, $data: string, $status: number)} $callback - \n     *            This function is called after the execution in order to send data and the status \n     *              to the calling function.\n     */\n    this.deleteCategory = function($id, $callback) {\n        $http({\n            method : 'DELETE',\n            url : $serverRestLocation.getValue() + '/categories/' + $id, \n            headers: {  'Content-Type':'application/json'},\n            data: { \n                \"name\" : $id\n                }\n        })\n        .success(function(data, status) {\n            console.log(data);\n            if($callback !== undefined){\n            $callback(true, data, status);\n            }\n        })\n        .error(function(data, status) {\n            console.log(data);\n            if($callback !== undefined){\n           $callback(false, data, status);\n            }\n        });\n    };\n    \n    \n    this.loadSomeQueriesInExpertMode = function($callback, $name, $category, $description) {\n        var filter = \"?\";\n        if($name !== null && $name !== undefined && $name !== \"\"){\n            filter = filter + \"name=\" + $name;\n        }\n        if($category !== null && $category !== undefined && $category !== \"\"){\n            if(filter !== \"?\"){\n                 filter = filter + \"&\";\n            }\n            filter = filter + \"category=\" + $category;\n        }\n        if($description !== null && $description !== undefined && $description !== \"\"){\n            if(filter !== \"?\"){\n                 filter = filter + \"&\";\n            }\n            filter = filter + \"description=\" + $description;\n        }\n        if(filter != \"?\"){\n            $http({\n                method : 'GET',\n                url : $serverRestLocation.getValue() + '/expertqueries/' + filter, \n                headers: { \n                        'Content-Type':'application/json'\n                }\n            })\n            .success(function(data, status) {\n                $callback(true, data, status); \n            })\n            .error(function(data, status) {\n                $callback(false, data, status);\n            });\n        }\n        else{\n            this.loadAllQueries($callback);\n        }\n       \n    };\n\n    /**\n     * This method gets all existing users.\n     *\n     * @param {function($success: number, $data: string, $status: number)} $callback - \n     *            This function is called after the execution in order to send data and the status \n     *              to the calling function.\n     */\n    this.getAllUsers = function($callback) {\n        $http({\n            method : 'GET',\n            url : $serverRestLocation.getValue() + '/users', \n            headers: { \n                    'Content-Type':'application/json'\n            }\n        })\n        .success(function(data, status) {\n            $callback(true, data, status); \n        })\n        .error(function(data, status) {\n            $callback(false, data, status);\n        });\n    };\n\n\n    /**\n     * This method gets all existing authorities of a specific user.\n     *\n     * @param {string} $id -  The id of the user for who the authorities should be returned.\n     * @param {function($success: number, $data: string, $status: number)} $callback - \n     *            This function is called after the execution in order to send data and the status \n     *              to the calling function.\n     */\n    this.getAllAuthorities = function($id, $callback) {\n        $http({\n            method : 'GET',\n            url : $serverRestLocation.getValue() + '/user/'+ $id, \n            headers: { \n                    'Content-Type':'application/json'\n            }\n        })\n        .success(function(data, status) {\n            $callback(true, data, status); \n        })\n        .error(function(data, status) {\n            $callback(false, data, status);\n        });\n    };\n\n    /**\n     * This method adds a authority to a specific user.\n     *\n     * @param {string} $email -  The email of the user to who the authorities should be added.\n     * @param {string} $authority -  The authority which should be added.\n     * @param {function($success: number, $data: string, $status: number)} $callback - \n     *            This function is called after the execution in order to send data and the status \n     *              to the calling function.\n     */\n    this.addAuthority = function($email, $authority, $callback) {\n        $http({\n            method : 'POST',\n            url : $serverRestLocation.getValue() + '/user/'+ $email+ '/authority', \n            headers: {  'Content-Type':'application/json'},\n            data: { \n              \"authority\" : $authority }\n        })\n        .success(function(data, status) {\n            console.log(data);\n            if($callback !== undefined){\n            $callback(true, data, status);\n            }\n        })\n        .error(function(data, status) {\n            console.log(data);\n            if($callback !== undefined){\n           $callback(false, data, status);\n            }\n        });\n    };  \n\n    /**\n     * This method deletes a authority from a specific user.\n     *\n     * @param {string} $email -  The email of the user from who the authorities should be deleted.\n     * @param {string} $authority -  The authority which should be deleted.\n     * @param {function($success: number, $data: string, $status: number)} $callback - \n     *            This function is called after the execution in order to send data and the status \n     *              to the calling function.\n     */\n    this.deleteAuthority = function($email, $authority, $callback) {\n        $http({\n            method : 'DELETE',\n            url : $serverRestLocation.getValue() + '/user/' + $email + '/authority', \n            headers: {  'Content-Type':'application/json'},\n            data: { \n                \"authority\" : $authority\n                }\n        })\n        .success(function(data, status) {\n            console.log(data);\n            if($callback !== undefined){\n            $callback(true, data, status);\n            }\n        })\n        .error(function(data, status) {\n            console.log(data);\n            if($callback !== undefined){\n           $callback(false, data, status);\n            }\n        });\n    };   \n\n\n\n}]);\n",
    "static": true,
    "longname": "App/services.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 18,
    "kind": "file",
    "name": "App/user/user.js",
    "content": "'use strict';\r\n\r\nangular.module('queryBuilder.user', ['ngRoute', 'queryBuilder.services'])\r\n\r\n.config(['$routeProvider', function($routeProvider) {\r\n  $routeProvider.when('/user', {\r\n    templateUrl: 'user/user.html'\r\n  });\r\n}])\r\n.controller('userCtrl', ['$requests',\r\n\tfunction($requests) {\r\n\tvar self = this;\r\n\t\r\n\r\n\t/**\r\n     * Holds email of selected user.\r\n     * @type {string}\r\n     */\r\n\tself.email = \"\";\r\n\r\n\t /**\r\n     * Stores all Users which exists.\r\n     * @type {array}\r\n     */\t\r\n  \tself.existingUsers = [];\r\n\r\n\t/**\r\n     * Store all authorities of selected user.\r\n     * @type {array}\r\n     */\r\n  \tself.authorities = [];\r\n\r\n\t/**\r\n     * Store all roles of the user which can be selected and changed.\r\n     * @type {array}\r\n     */\r\n   \tself.roles = [\r\n   \t 'EXPERTMODE', \r\n  \t 'CATEGORY', \r\n   \t 'ALERT', \r\n   \t 'ALERTSTATISTIC'\r\n  \t];\r\n\r\n\t/**\r\n     * Holds the error string which is displayed to the user.\r\n     * The table is only shown when the hasError property is set to TRUE.\r\n     * @type {string}\r\n     */\r\n\tself.error = \"\";\r\n\t/**\r\n     * If there was an error during the execution of the query this is set to \r\n     * true and the error will be displayed. Otherwise the table will be displayed.\r\n     * @type {boolean}\r\n     */\r\n\tself.hasError = false;\r\n\t\r\n\t/**\r\n\t * Callback from delete/save category call. If query was successful refresh category names.\r\n\t * Otherwise print error.\r\n\t *\r\n\t * @param {boolean} $success - true when there are no errors.\r\n\t * @param {Object} $data - the requested data.\r\n     * @param {number} $status - the actual server status.\r\n\t */\r\n\tself.callback = function($success, $data, $status) {\r\n\t\tself.hasError = !$success;\r\n\t\tif($success){\r\n\t\t\t$requests.getAllUsers(self.getUsers);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tself.error = $data;\r\n\t\t}\r\n\t}\r\n\t/**\r\n\t * Callback from get all users call. If query was successful save data in variable self.existingUsers.\r\n\t * Otherwise print error.\r\n\t * \r\n\t * @param {boolean} $success - true when there are no errors.\r\n\t * @param {Object} $data - the requested data (In this case the users).\r\n     * @param {number} $status - the actual server status.\r\n\t */\r\n\tself.getUsers = function($success, $data, $status) {\r\n\t\tself.hasError = !$success;\r\n\t\tif($success){\r\n\t\t\tself.existingUsers = $data;\r\n\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tself.error = $data;\r\n\t\t}\r\n\t}\t\r\n\t$requests.getAllUsers(self.getUsers);\r\n\r\n\t/**\r\n    * This method searches for a certain role with a certain role name (key).\r\n    *\r\n    * @param {string} $key - The key of the role. The key is the same as the role name.\r\n    * @return {Object} The given role name or undefined.\r\n    */\r\n\tself.getRoles = function($key){\t\r\n\t\tfor (var i = 0; i < self.authorities.length; i++) {\r\n\t\t\tif(self.authorities[i].authority === $key){\r\n\t\t\t\treturn $key;\t\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn undefined;\r\n\t};\r\n\r\n\t/**\r\n    * Checks whether a certain role with a role name (key) exists or not.\r\n    *\r\n    * @param {string} $key - The role key. The key is the same as the role name.\r\n    * @return {boolean} True if the role with the given key exists, otherwise false.\r\n    */\r\n\tself.isRoleChecked = function($key){\r\n\t\tif(self.getRoles($key) === undefined){\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn true;\r\n\t};\r\n\r\n\t/**\r\n        * Checks whether a certain role with a certain key exists or not.\r\n        * If it exists it removes the role, if not it creates the role.\r\n        * \r\n        * @param {string} $key - The key of the property which should be added or deleted.\r\n        */\r\n    self.setFilterAttributes = function($key){\r\n        var filterAttribute = self.getRoles($key);\r\n\t\t\tif(filterAttribute !== undefined){\r\n                $requests.deleteAuthority(self.email, $key, self.callback)\r\n\r\n            } else {\r\n                $requests.addAuthority(self.email, $key, self.callback)\r\n            }\r\n\r\n    }\r\n\r\n\t/**\r\n\t * Callback from get all authorities call. If query was successful save data in variable self.authorities.\r\n\t * Otherwise print error.\r\n\t * \r\n\t * @param {boolean} $success - true when there are no errors.\r\n\t * @param {Object} $data - the requested data (In this case the authorities).\r\n     * @param {number} $status - the actual server status.\r\n\t */\r\n    self.getAuthorities = function($success, $data, $status) {\r\n\t\tself.hasError = !$success;\r\n\t\tif($success){\r\n\t\t\tself.authorities = $data;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tself.error = $data;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Load selected authorities of selected user.\r\n\t * \r\n\t * @param {Object} $query - Load this query.\r\n\t */\r\n    self.selectLoad = function($query) {\r\n        $requests.getAllAuthorities($query.email, self.getAuthorities);\r\n        self.email = $query.email;\r\n    }\t\t\r\n}]);",
    "static": true,
    "longname": "App/user/user.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Infinity",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~NaN",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~undefined",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~null",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Object",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~object",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Function",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~function",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Boolean",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~boolean",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Symbol",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Error",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~EvalError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~InternalError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~RangeError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~ReferenceError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~SyntaxError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~TypeError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~URIError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Number",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~number",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Date",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~String",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~string",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~RegExp",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int8Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint8Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint8ClampedArray",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 49,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int16Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 50,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint16Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 51,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int32Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 52,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint32Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 53,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Float32Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 54,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Float64Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 55,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Map",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 56,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Set",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 57,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~WeakMap",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 58,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~WeakSet",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 59,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~ArrayBuffer",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 60,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~DataView",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 61,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~JSON",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 62,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Promise",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 63,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Generator",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 64,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~GeneratorFunction",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 65,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Reflect",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 66,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Proxy",
    "access": null,
    "description": "",
    "lineNumber": 193,
    "builtinExternal": true
  },
  {
    "__docId__": 68,
    "kind": "external",
    "name": "CanvasRenderingContext2D",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~CanvasRenderingContext2D",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 69,
    "kind": "external",
    "name": "DocumentFragment",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~DocumentFragment",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 70,
    "kind": "external",
    "name": "Element",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Element",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~Element",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 71,
    "kind": "external",
    "name": "Event",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Event",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~Event",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 72,
    "kind": "external",
    "name": "Node",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Node",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~Node",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 73,
    "kind": "external",
    "name": "NodeList",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/NodeList",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~NodeList",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 74,
    "kind": "external",
    "name": "XMLHttpRequest",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~XMLHttpRequest",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 75,
    "kind": "external",
    "name": "AudioContext",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/API/AudioContext",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~AudioContext",
    "access": null,
    "description": "",
    "lineNumber": 34,
    "builtinExternal": true
  }
]
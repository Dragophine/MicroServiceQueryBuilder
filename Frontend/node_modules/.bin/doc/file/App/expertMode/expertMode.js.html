<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">App/expertMode/expertMode.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  </ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">App/expertMode/expertMode.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use strict&apos;;

angular.module(&apos;queryBuilder.expertMode&apos;, [&apos;ngRoute&apos;, &apos;queryBuilder.services&apos;])

.config([&apos;$routeProvider&apos;, function($routeProvider) {
  $routeProvider.when(&apos;/expertmode&apos;, {
    templateUrl: &apos;expertMode/expertMode.html&apos;
  });
}])
/**
   * This controller handles the main operation in the user interface.
   * It configures and handle all actions in the expert mode.
   * 
   * @version 1.0.0
   */
.controller(&apos;expertModeCtrl&apos;, [&apos;$requests&apos;,&apos;$rootScope&apos;, &apos;ngDialog&apos;,
	function($requests, $rootScope, ngDialog) {

    var self = this;
    
    /**
     * Uses a &quot;CodeMirror&quot; textArea with syntax highlighting.
     * For further information about CodeMirror look at
     * https://codemirror.net/
     */
    self.myCodeMirror = CodeMirror.fromTextArea(document.getElementById(&apos;query&apos;), {
        mode: &apos;cypher&apos;,
        indentWithTabs: true,
        smartIndent: true,
        lineNumbers: true,
        matchBrackets : true,
        autofocus: true,
        theme: &apos;neo&apos;,
        viewportMargin: Infinity
      });
    
    self.query = &quot;&quot;;
    /**
     * Store the parameter from selected query in this array.
     * @type {array}
     */
	self.params = [];
    /**
     * If a value from expert query is missing or invalid in save dialog
     * a message will be stored in this array.
     * @type {array}
     */
	self.invalidSaveText = [];
	
	/**
	 * Whenever the query changes, the parameters should be adjusted automatically.
	 * Parameters are currently recognized by &quot;{&quot;.
	 * 
	 * @param {Object} cMirror - is the &quot;CodeMirror&quot; textarea from view.
	 */
    self.myCodeMirror.on(&apos;change&apos;,function(cMirror){
    		self.query = cMirror.getValue();
    		$rootScope.expertQuery = query;
    		var paramcnt = self.query.split(&quot;{&quot;).length - 1;
    		var keys = &apos;&apos;;
    		var startIndex = 0;
    		var endIndex = 0;
    		
    		// Removing and regenerating parameters
    		self.params = [];
    		
    		/**
    		 * The first parameter is read out because a parameter could already 
    		 * be present at position 0, although this will not be a correct 
    		 * statement ...
    		 */
    		startIndex = self.query.indexOf(&quot;{&quot;, startIndex);
    		endIndex = self.query.indexOf(&quot;}&quot;, startIndex);
    		keys = self.query.substring(startIndex+1, endIndex);
    		    		
    		var i;
    		for(i = 0; self.params.length &lt; paramcnt; i++)
    		{
    			self.params.push.apply(self.params, [{key: keys, type : &quot;int&quot;, value : &quot;&quot;}]);
        		startIndex = self.query.indexOf(&quot;{&quot;, startIndex+1);
        		endIndex = self.query.indexOf(&quot;}&quot;, startIndex+1);
        		keys = self.query.substring(startIndex+1, endIndex);
    		}
        	$rootScope.$apply();
    	});
    	
    /**
     * Selectable parameter types.
     */
	self.paramoptions = [&quot;int&quot;, &quot;String&quot;, &quot;double&quot;, &quot;long&quot;, &quot;boolean&quot;];
	/** 
	 * The following three variables are query fields in save dialog.
	 */
	self.name = &quot;&quot;;
	self.description = &quot;&quot;;
	self.category = &quot;&quot;;

	//sets actual query from expert mode
	if(	$rootScope.expertQuery !== undefined){
		self.myCodeMirror.setValue($rootScope.expertQuery);
	}
	//set query from querybuilder to expertmode
	else if($rootScope.queryBuilderQueryInCypher !== undefined){
		self.myCodeMirror.setValue($rootScope.queryBuilderQueryInCypher );
	}

	/** 
		Table json (simply the result)
	*/
	self.table = &quot;&quot;;
	 /**
     * Holds the error string which is displayed to the user.
     * The table is only shown when the hasError property is set to TRUE.
     * @type {string}
     */
	self.error = &quot;&quot;;
	 /**
     * If there was an error during the execution of the query this is set to 
     * true and the error will be displayed. Otherwise the table will be displayed.
     * @type {boolean}
     */
	self.hasError = false;	
	/**
	 * All existing queries. This queries will be shown in load/delete dialog.
     * @type {array}
	 */
	self.queries = [];
	/**
	 * Modal dialog for saving queries.
     * @type {object}
	 */
	var modalSave = document.getElementById(&apos;myModalSave&apos;);	
	/**
	 * Save button which opens save modal dialog.
     * @type {object} 
	 */
	var btnSave = document.getElementById(&quot;saveQuery&quot;);
	/**
	 * Load button which opens load/delete ngDialog.
     * @type {object} 
	 */
	var btnLoad = document.getElementById(&quot;loadQuery&quot;);
	/**
	 * Delete button which opens load/delete ngDialog.
     * @type {object} 
	 */
	var btnDelete = document.getElementById(&quot;deleteQuery&quot;);
	/**
	 * cancel-button from modal dialog for missing or invalid data.
     * @type {object}
	 */
	var saveAbbruch = document.getElementById(&quot;saveAbbruch&quot;);

	/**
	 * When the user clicks on the button, open the modal dialog
	 * for saving queries.
	 */
	btnSave.onclick = function() {
		self.invalidSaveText = [];
		modalSave.style.display = &quot;block&quot;;
		
	}
	/**
	 * When the user clicks on the button, open the ngDialog
	 * for loading/deleting queries.
	 */
	btnLoad.onclick = function() {
		$requests.loadAllQueries(self.queriesCB);
		
		var dialog = ngDialog.open({ template: &apos;expertMode/loadDialogExpertMode.html&apos;,
			className: &apos;ngdialog-theme-default custom-width&apos;,
			controller: &apos;loadDialogExpertModeCtrl&apos;,
			controllerAs: &apos;ctrl&apos;});
		
		/**
		 * Close ngDialog is only possible if user select a load button or
		 * select close button. Check if user has select the load button.
		 */
		dialog.closePromise.then(function ($data) {
        	if($data !== undefined &amp;&amp; $data.value !== undefined &amp;&amp;
        			$data.value.query !== undefined)
        	{
        		self.select($data.value);
        	}
		});
	}
	/**
	 * When the user clicks on the button, open the ngDialog
	 * for loading/deleting queries.
	 */	
	btnDelete.onclick = function() {
		$requests.loadAllQueries(self.queriesCB);
		
		var dialog = ngDialog.open({ template: &apos;expertMode/loadDialogExpertMode.html&apos;,
			className: &apos;ngdialog-theme-default custom-width&apos;,
			controller: &apos;loadDialogExpertModeCtrl&apos;,
			controllerAs: &apos;ctrl&apos;});
		
		/**
		 * Close ngDialog is only possible if user select a load button or
		 * select close button. Check if user has select the load button.
		 */
		dialog.closePromise.then(function ($data) {
        	if($data !== undefined &amp;&amp; $data.value !== undefined &amp;&amp;
        			$data.value.query !== undefined)
        	{
        		self.select($data.value);
        	}
		});
	}

	/**
	 * User has cancelled the save dialog. Reset values, otherwise they will be 
	 * displayed again by in next save dialog.
	 */
	saveAbbruch.onclick = function() {
		self.name = &quot;&quot;;
		self.description = &quot;&quot;;
		self.category = &quot;&quot;;
		// close save dialog
		modalSave.style.display = &quot;none&quot;;
	}

	/**
	 * Callback from execute, delete and save query. If query was successful show result in table.
	 * Otherwise print error.
	 * 
	 * @param {boolean} $success - true when there are no errors.
	 * @param {Object} $data - the requested data.
     * @param {number} $status - the actual server status.
	 */
	self.callback = function($success, $data, $status) {
		self.hasError = !$success;
		if($success){
			self.table = $data;
		}
		else
		{
			self.error = $data;
		}
	}
	
	/**
	 * Callback from get all queries call. If query was successful save data in variable self.queries.
	 * Otherwise print error.
	 * 
	 * @param {boolean} $success - true when there are no errors.
	 * @param {Object} $data - the requested data (In this case the queries).
     * @param {number} $status - the actual server status.
	 */
	self.queriesCB = function($success, $data, $status){
		self.hasError = !$success;
		if($success)
		{
			self.queries = $data;
		}
		else
		{
			self.error = $data;
		}
	}

	/**
	 * Execute actual query.
	 */
	self.submitQuery = function() {
		$requests.getResultFromQuery(self.myCodeMirror.getValue(), self.params, self.callback);
	}
	
	/**
	 * Save actual query if all fields in save dialog were filled correctly and query name
	 * do not exists until now.
	 */
	self.saveQuery = function()
	{
		self.invalidSaveText = [];
		var queryName = self.name;
		$requests.loadAllQueries(self.queriesCB);
		
		if(!existsQueryName(queryName))
		{
			console.log(self.categoryName);
			self.invalidSaveText = [];
			$requests.saveQuery(self.myCodeMirror.getValue(), self.params, 
					queryName, self.description, self.categoryName, self.callback);
			// Reset values, otherwise they will be displayed again by in next save dialog.
			self.name = &quot;&quot;;
			self.description = &quot;&quot;;
			self.category = &quot;&quot;;
			// Close save dialog
			modalSave.style.display = &quot;none&quot;;
		}
		else
		{
			self.invalidSaveText.push(&quot;Der Queryname existiert bereits, &quot; +
					&quot;verwenden Sie bitte einen anderen Querynamen.&quot;);
		}
	}
	
	/**
	 * Delete actual query.
	 */
	self.deleteSelectedQuery = function($query)
	{
		$requests.deleteQuery($query.query, $query.parameter, 
				$query.name, $query.description, $query.category, self.callback);
	}
	
	/**
	 * Load selected query.
	 * 
	 * @param {Object} $query - query which should be load.
	 */
	self.select = function($query) {		
		self.myCodeMirror.setValue($query.query);
		
		self.params = [];
		var arrLength = $query.parameter.length;
		var i;
		for(i = 0; self.params.length &lt; arrLength; i++)
		{
    		self.params.push.apply(self.params, [{key: $query.parameter[i].key, type : $query.parameter[i].type,
    			value : $query.parameter[i].value}]);
		}
	}
	
	/**
	 * Check if the queryName already exists.
	 * 
	 * @param {Object} $$queryName - query name which should be checked.
	 */
	function existsQueryName($queryName)
	{
	    for (var i = 0; i &lt; self.queries.length; i++)
	    {
	        if (self.queries[i].name === $queryName)
	        {
	            return true;
	        }
	    }
	    return false;
	}

	/**
	 * Stores all available categories.
     * @type {array} 
	 */
	self.availableCategories = [];
	/**
	 * Actual selected category name.
     * @type {string} 
	 */
	self.categoryName = &quot;&quot;;


	/**
	 * Callback from get all categories. If query was successful save data in variable self.availableCategories.
	 * The categories are displayed in the save dialog and in the load/delete dialog.
	 * Otherwise print error.
	 * 
	 * @param {boolean} $success - true when there are no errors.
	 * @param {Object} $data - the requested data (In this case the categories).
     * @param {number} $status - the actual server status.
	 */
	self.getCategories = function($success, $data, $status){
		self.hasError = !$success;
		if($success){
			self.availableCategories = $data;
		}
		else
		{
			self.error = $data;
		}
	}
	$requests.getAllCategories(self.getCategories);
}]);</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">App/querybuilder/querybuilder.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  </ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">App/querybuilder/querybuilder.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use strict&apos;;

angular.module(&apos;queryBuilder.querybuilder&apos;, [&apos;ngRoute&apos;, &apos;queryBuilder.services&apos;])

.config([&apos;$routeProvider&apos;, function($routeProvider) {
  $routeProvider.when(&apos;/querybuilder&apos;, {
    templateUrl: &apos;querybuilder/querybuilder.html&apos;
  });
}])
/**
   * This controller handles the main operation in the user interface.
   * It configures vis.js, opens a dialog when a node or a relationship was clicked, 
   * draws the graph, executes the query and saves or updates the query.  
   * 
   * @version 1.0.0
   */
.controller(&apos;queryBuilderCtrl&apos;, [&apos;$requests&apos;, &apos;$rootScope&apos;, &apos;$scope&apos;,&apos;ngDialog&apos;,
	function($requests, $rootScope, $scope, ngDialog) {
    var self = this;

     /**
     * The query which will be built with the query builder.
     * This saves the core information about the query.
     * @type {Object}
     */
    self.query = {
    	&quot;id&quot;:&quot;&quot;,
    	&quot;name&quot;:&quot;&quot;,
        &quot;author&quot;:  $rootScope.principal.username,
    	&quot;description&quot;:&quot;&quot;,
    	&quot;category&quot;:&quot;&quot;,
    	&quot;limitCount&quot;: &quot;&quot;,
        &quot;skip&quot;:&quot;&quot;,
    	&quot;distinct&quot;:false,
    	&quot;node&quot;:&quot;&quot;          
    }


    /**
     * The cypher query which is displayed to the user.
     * @type {string}
     */
   	self.displayQuery = &quot;&quot;;

   	/**
     * The node ID Store saves the id of the node in the vis.js network with
     * the corresponding node in the query.
     * @type {Object}
     */
    self.nodeIDStore = {};
    /**
     * The relationship ID Store saves the id of the relationship
     * in the vis.js network with
     * the corresponding relationship in the query.
     * @type {Object}
     */
    self.relationshipIDStore = {};
    /**
     * Holds the selected node from the vis network.
     * @type {Object}
     */
    self.selectedNode = undefined;

    /**
     * Holds the selected releation from the vis network.
     * @type {Object}
     */
    self.selectedRelation = undefined;
	 /**
     * Holds the selected releation from the vis network.
     * @type {Object}
     */
	self.availableNodes = &quot;&quot;;

	 /**
     * Holds the data for the output table in the querybuilder network.
     * The table is only shown when the hasError property is set to FALSE.
     * @type {Object}
     */
	self.table = &quot;&quot;;
	 /**
     * If there was an error during the execution of the query this is set to 
     * true and the error will be displyed. Otherwise the table will be displayed.
     * @type {boolean}
     */
	self.hasError = false;
	 /**
     * Holds the error string which is displayed to the user.
     * The table is only shown when the hasError property is set to TRUE.
     * @type {string}
     */
	self.error = &quot;&quot;;

	 /**
     * Holds all available categories.
     * @type {Object}
     */
	self.availableCategories = [];
   
   	/**
   	 * Transfers the actual query into a graph 
   	 * which can be displayed with vis.js.
	 * This method will be called whenever the self.query property
     * changes. 
     * Furthermore, this method creates the ids for the nodes and for the 
     * relationships which are required for the vis.js network.
   	 * In order to find out, which id corresponds to which node or to which relationship in 
   	 * the query a relationshipIDStore and a nodeIDStore is needed.
   	 *
   	 * @param {visnetwork} $network - the network behind the vis graph (optional).
   	 */
    self.transfersToGraph = function($network){
    	var $nodeID = 1;
    	var $relationshipID = 0;

    	for (var id in self.relationshipIDStore) {
		  if (self.relationshipIDStore.hasOwnProperty(id)) {
		    self.edges.remove(id);
		  }
		}

    	for (var id in self.nodeIDStore) {
		  if (self.nodeIDStore.hasOwnProperty(id)) {
		    self.nodes.remove(id);
		  }
		}

    	self.nodeIDStore = {};
    	self.relationshipIDStore = {};

    	function transfersToGraphRecursion($parrentid, $relationship){
    		var $node = $relationship[&apos;node&apos;];

    		if($node != undefined){
 
    			$nodeID = $nodeID + 1;
    			$relationshipID = $relationshipID +1;
    			//save variable value because $nodeId and $relationship id can be changed by a other
    			//execution
    			var $nID = $nodeID;
    			var $rID = $relationshipID;

    			self.nodes.add([{id: $nID, label: $node[&apos;type&apos;]}]);
    			if($relationship[&apos;direction&apos;] === &quot;INGOING&quot;){
  					self.edges.add([{id: $rID, from: $nID, to: $parrentid, label: $relationship[&apos;relationshipType&apos;]}]);
    			}
    			else{
    				self.edges.add([{id: $rID, from: $parrentid, to: $nID, label: $relationship[&apos;relationshipType&apos;]}]);
    			}

    			self.nodeIDStore[$nID] = $node;
    			self.relationshipIDStore[$rID] = $relationship;

    			if($node[&quot;relationship&quot;] != undefined){
    				for (var i = 0; i &lt; $node[&quot;relationship&quot;].length; i++){
					    var rel = $node[&quot;relationship&quot;][i];
					    transfersToGraphRecursion($nID, rel);
					}
    			}
    		}
    	}

    	if(self.query[&quot;node&quot;] !== undefined ){

    			var $rootNode = self.query[&quot;node&quot;];
    		 	//Root node
    			 self.nodes.add([{id: 1, label: $rootNode[&quot;type&quot;], color: &apos;#009900&apos;}]);
    			 self.nodeIDStore[1] = $rootNode;

    			 //every additional node
    			 if($rootNode[&quot;relationship&quot;] != undefined){
    				for (var i = 0; i &lt; $rootNode[&quot;relationship&quot;].length; i++){
					    var rel = $rootNode[&quot;relationship&quot;][i];
					    transfersToGraphRecursion(1, rel);
					}
    			}
    	}
    	if($network !== undefined){
    		$network.fit();
    		$network.redraw();
    	}
    	
    };

  	 /**
    * This method opens an info dialog. It displays a certain data (head and content)
    * given in the $data. Furthermore, a callback can be specified, when the dialg is closed.
    *
    * @param {!Object} $data - the head an the content for the info dialog.
    * @param {?function} infoClosePromis - The function which should be called when the dialog is closed.
    */
    self.showInfoDialog = function($data, infoClosePromis){
    	var dialog = ngDialog.open({ template: &apos;querybuilder/infoDialog.html&apos;,
        				className: &apos;ngdialog-theme-default custom-width&apos;,
        				controller: &apos;querybuilderInfoDialogCtrl&apos;,
        				controllerAs: &apos;ctrl&apos;,
        				data:$data
        		 });
    	if(infoClosePromis !== undefined){
    		dialog.closePromise.then(infoClosePromis);
    	}
    }
	
     /**
    * This method checks whether a query is valid before updating and saving.
    * Only valid queries should be sent to the server.
    * 
    * @return {Object} The error message or undefined.
    */
	self.checkInputData = function(){
		var $data = undefined;
		if(self.query.name === &quot;&quot; || self.query.name === undefined
			|| self.query.name === null){
			$data = {
				&quot;head&quot;:&quot;No name&quot;,
				&quot;content&quot;:&quot;Please enter a name before you save/update the query.&quot;
			};
		}
		else if(self.query.description === &quot;&quot;|| self.query.description === undefined
			|| self.query.description === null){
			$data = {
				&quot;head&quot;:&quot;No description&quot;,
				&quot;content&quot;:&quot;Please enter a description before you save/update the query.&quot;
			};
		}
		else if(self.query.category === &quot;&quot;|| self.query.category === undefined
			|| self.query.category === null){
			$data = {
				&quot;head&quot;:&quot;No category&quot;,
				&quot;content&quot;:&quot;Please enter a category before you save/update the query.&quot;
			};
		}
		else if(self.query.node === &quot;&quot;|| self.query.node === undefined
			|| self.query.node === null){
			$data = {
				&quot;head&quot;:&quot;No node&quot;,
				&quot;content&quot;:&quot;Please enter a node before you save/update the query.&quot;
			};
		}
    	return $data;
	}

	  /**
        * The callback when the requested query was loaded.
        * The query is the cypher query which is displayed to the user.
        *
        * @param {boolean} $success - true when there are no errors.
        * @param {Object} $data - the requested data (In this case the query).
        * @param {number} $status - the actual server status.
        */
	self.getQueryCallback = function($success, $data, $status){
		if($success){
			self.displayQuery = $data;
			$rootScope.queryBuilderQueryInCypher = $data.query;
		}
		else
		{
			self.displayQuery = &quot;&quot;;
			$rootScope.queryBuilderQueryInCypher = undefined;
		}
    }

    /**
     * This method should be (will be) called every time the query changes.
     * It saves a copy of the actual query to the root scope. This is 
     * necessary if the user switches tabs he wants to have the same 
     * query when he comes back. Furthermore, the cypher query will be created.
     */
    self.onQueryChanged = function(){
    	$rootScope.queryBuilderOldQuery = self.query;
    	$requests.getQueryFromQueryQueryBuilder(self.query, self.getQueryCallback);
    }

   
 	/**
    * The callback is executed when the query is executed.
    * If there is an error in the query the error will be displayed otherwise the
    * result.
    *
    * @param {boolean} $success - true when there are no errors.
    * @param {Object} $data - the requested data (The error or the result of the query.).
    * @param {number} $status - the actual server status.
    */
	self.executeQueryCallback = function($success, $data, $status) {
		self.hasError = !$success;
		if($success){
			self.table = $data;
		}
		else
		{
			self.error = $data;
		}
	}

	 /**
     * This method executes a query and displays the result in a table 
     * or displays the error message.
     */
	self.executeQuery = function() {
		self.onQueryChanged();
		$requests.getResultFromQueryQueryBuilder(self.query, self.executeQueryCallback);
	}

	  /**.
        * The callback when user requested to save the query.
        * This method displays a success or an error message to the user.
        * Only new queries can be saved. If an existing should be saved an
        * update needs to be done.
        *
        * @param {boolean} $success - true when there are no errors.
        * @param {Object} $data -. the requested data (The new id of the query).
        * @param {number} $status - the actual server status.
        */
	self.saveQueryCallback = function($success, $data, $status) {
		var $dataForDialog = undefined;
		if($success){
			$dataForDialog = {
				&quot;head&quot;:&quot;Successfully saved&quot;,
				&quot;content&quot;:&quot;The query was saved successfully.&quot;
			};
			self.query.id = $data;
		}
		else
		{
			$dataForDialog = {
				&quot;head&quot;:&quot;Error when saving&quot;,
				&quot;content&quot;:&quot;Error when saving the query. Info: &quot; + $data
			};
		}

		 self.showInfoDialog($dataForDialog);

		
	}

	 /**
     * This method saves a query and displays if the process was successful or not.
     * Only new queries can be saved. If an existing should be saved an
     * update needs to be done.
     */
	self.saveQuery = function(){
		var $data =self.checkInputData();

    	if($data === undefined){

    		$requests.saveQueryInBuilder(self.query, self.saveQueryCallback);
    	}
    	else
    	{
    		self.showInfoDialog($data);
    	}
		self.onQueryChanged();
	}

	  /**.
        * The callback when user requested to update the query.
        * This method displays a success or an error message to the user.
        * Before one can do an update, the query must be saved first.
        *
        * @param {boolean} $success - true when there are no errors.
        * @param {Object} $data - useless, because no data was requested.
        * @param {number} $status - the actual server status.
        */
	self.updateQueryCallback = function($success, $data, $status) {
		var $data = undefined;
		if($success){
			$data = {
				&quot;head&quot;:&quot;Successfully updated&quot;,
				&quot;content&quot;:&quot;The query was updated successfully.&quot;
			};
		}
		else
		{
			$data = {
				&quot;head&quot;:&quot;Error when updating&quot;,
				&quot;content&quot;:&quot;Error when updating the query. Info: &quot; + $data
			};
		}

		 self.showInfoDialog($data);	
	}

	/**
	 * This method updates a certain query.
	 * This method displays a success or an error message to the user.
     * Before one can do an update, the query must be saved first.
	 */
	self.updateQuery = function(){
		var $data =self.checkInputData();
		if($data === undefined){
    		$requests.updateQueryInBuilder(self.query, self.query.id, self.updateQueryCallback);
    	}
    	else
    	{
    		self.showInfoDialog($data);
    	}
		self.onQueryChanged();
	}


	/**
	 * This method contains the logic for loading a query.
	 * It sets all the paramerters according to the data of the query.
	 * (Initializes vis.js, load initial nodes if they are required, shows cypher query, e.g.)
	 * 
	 * @param {Object} $query - the query which should be loaded.
	 */
	self.loadQueryLogic = function($query){
		if( $query !== undefined &amp;&amp;
    		$query.name !== undefined &amp;&amp;
    		$query.description !== undefined &amp;&amp;
    		$query.category !== undefined)
    	{
    		self.query = $query;
    		self.selectedNode = undefined;
    		self.selectedRelation = undefined;
    		self.table = &quot;&quot;;
    		self.onQueryChanged();
    		self.hasError = false;

    		//checks weather query has already properties or is empty
    		if(
    		   $query.node !== undefined &amp;&amp;
    		   $query.node !== &quot;&quot; &amp;&amp;
    		   $query.node.type !== undefined &amp;&amp;
    		   $query.node.type !== &quot;&quot; )
    		{
    		   	self.availableNodes =  [];
    		}
    		else{
    			$requests.getNodes(self.getNodesCB);
    		}
	     	self.transfersToGraph(self.network);
            self.hasPermissions = (self.query.author === $rootScope.principal.username);
    	}
	}


	/**
	 * This method opens the load query dialog.
	 * If the user selects a certain query it loads it.
	 */
	self.loadQuery = function(){
		var dialog = ngDialog.open({ template: &apos;querybuilder/loadDialog.html&apos;,
	        				className: &apos;ngdialog-theme-default custom-width&apos;,
	        				controller: &apos;querybuilderLoadDialogCtrl&apos;,
	        				controllerAs: &apos;ctrl&apos;});


        dialog.closePromise.then(function ($data) {
        	if($data !== undefined)
        	{
        		self.loadQueryLogic($data.value);
        	}
		});
	}


	

   /**.
    * The callback when user requested to delete the query.
    * This method displays a success or an error message to the user.
    *
    * @param {boolean} $success - true when there are no errors.
    * @param {Object} $data - useless, because no data was requested.
    * @param {number} $status - the actual server status.
    */
	self.deleteQueryCallback = function($success, $data, $status) {
		var $data = undefined;
		if($success){
			$data = {
				&quot;head&quot;:&quot;Successfully deleted&quot;,
				&quot;content&quot;:&quot;The query was saved successfully deleted.&quot;
			};
			self.newQuery();
		}
		else
		{
			$data = {
				&quot;head&quot;:&quot;Error when deleting&quot;,
				&quot;content&quot;:&quot;Error when deleting the query. Info: &quot; + $data
			};
		}
		
		 self.showInfoDialog($data);
	}

	/**
	 * This method deletes a certain query.
	 * It needs the id from the actual query.
	 */
	self.deleteQuery = function(){
		$requests.deleteQueryInBuilder(self.query.id, self.deleteQueryCallback);
		
	}

	/**
	 * This method creates a new query by overwriting the actutal one.
	 */
	self.newQuery = function(){
		var query = {
			&quot;id&quot;:&quot;&quot;,
            &quot;name&quot;:&quot;&quot;,
            &quot;author&quot;:  $rootScope.principal.username,
            &quot;description&quot;:&quot;&quot;,
            &quot;category&quot;:&quot;&quot;,
            &quot;limitCount&quot;: &quot;&quot;,
            &quot;skip&quot;:&quot;&quot;,
            &quot;distinct&quot;:false,
            &quot;node&quot;:&quot;&quot;      
	    }
	    self.loadQueryLogic(query);
	}


	/**
    * The callback when the requested categories were loaded
    *
    * @param {boolean} $success - true when there are no errors.
    * @param {Object} $data - the requested data (In this case the categories).
    * @param {number} $status - the actual server status.
    */
	self.getCategoriesCallback = function($success, $data, $status){
		if($success){
			self.availableCategories = $data;
		}
	}
	/**
	 * This command loads all categories.
	 */
	$requests.getAllCategories(self.getCategoriesCallback);

	 /**
   	 * The callback when the requested nodes were loaded.
     * The nodes are all node types that exist in the database.
     *
     * @param {boolean} $success - true when there are no errors.
     * @param {Object} $data - the requested data (In this case the nodes).
     * @param {number} $status - the actual server status.
     */
	self.getNodesCB = function($success, $data, $status){
		self.hasError = !$success;
		if($success){
			self.availableNodes = $data;
		}
		else
		{
			self.error = $data;
		}
	}

	 /**
   	 * This method adds the first node to a query.
   	 * The next nodes will be added with the nodeDialog.
     *
     * @param {string} $type - the type of the node.
     */
	self.addNode = function($type){
		/**
		Add initial node
		*/
		self.query[&apos;node&apos;] = {
			&quot;type&quot;: $type,
			&quot;returnAttributes&quot;: [],
			&quot;filterAttributes&quot;: [],
			&quot;orderByAttributes&quot;: [],
			&quot;relationship&quot;:[]
		}
		

		self.availableNodes = [];
		self.onQueryChanged();
		self.transfersToGraph(self.network);
	}

	 /**
   	 * This method searches the selected node and deletes it.
   	 * The selected node is saved in the property self.selectedNode. It firsts
   	 * checks whether the first node is the head node of the query.
   	 * If not, then it searches for the node in the query relationship tree and deletes it.
     */
	self.deleteSelectedNode = function(){
		//if node is head
		if(self.query.node ===  self.selectedNode){
			self.selectedNode = undefined;
			self.selectedRelation = undefined;
			self.query.node = undefined;
			self.table = &quot;&quot;;
			self.hasError = false;
			$requests.getNodes(self.getNodesCB);
		}
		//if node is not head
		else{
			if(self.deleteRecursion(self.query.node, self.selectedNode) === 1){
				self.selectedNode = undefined;
				self.selectedRelation = undefined;
			};
		}
		self.onQueryChanged();
		self.transfersToGraph(self.network);
		$scope.$apply();
	}

	/**
   	 * This method deletes the $nodeToDelete in the $nodeToCheck tree.
   	 * It goes along each relationship and searches for the right node.
   	 *
   	 * @param {Object} $nodeToCheck - The node tree.
     * @param {Object} $nodeToDelete - The node which should be deleted.
     * @return {number} O if this is the node which should be deleted. 
     *					1 if the node was deleted. 
     *					2 if the node was not found.
     */
	self.deleteRecursion = function($nodeToCheck, $nodeToDelete){
		if($nodeToCheck === $nodeToDelete){
			return 0; //delte node;
		}
		else {
			for (var i = $nodeToCheck.relationship.length - 1; i &gt;= 0; i--) {
				var res = self.deleteRecursion($nodeToCheck.relationship[i].node, $nodeToDelete);
				if(res === 0) //delete node
				{
					$nodeToCheck.relationship.splice(i, 1);
					return 1;
				}
				else if(res === 1) { //node already deleted
					return 1;
				}
				//if(res === 2) node not found.
			}
			return 2;//not found
		}
	}

	/**
	Vis settings
	*/
	 /**
     * The network used in vis.js.
     * @type {Object}
     */
	self.network = undefined;
	 /**
     * The representation of the nodes in vis.js.
     * @type {Object}
     */
	self.nodes = new vis.DataSet();
	 /**
     * The representation of the edges in vis.js.
     * The edges represnt the relationships.
     * @type {Object}
     */
    self.edges = new vis.DataSet();

    /**
     * The date for the vis.js network. 
     * @type {Object}
     */
    self.network_data = {
        nodes: self.nodes,
        edges: self.edges
    };

     /**
     * The options for the vis.js network.
     * For further documentation, please look at the vis.js website.
     * http://visjs.org/docs/network/
     * @type {Object}
     */
    self.network_options = {
    	
    	width:  &apos;100%&apos;,
    	height: &apos;500px&apos;,
		edges:{
		    arrows: {
		      to:     {enabled: true, scaleFactor:1, type:&apos;arrow&apos;},
		      middle: {enabled: false, scaleFactor:1, type:&apos;arrow&apos;},
		      from:   {enabled: false, scaleFactor:1, type:&apos;arrow&apos;}
		    }
		},
		layout: {
			randomSeed: 50,

			hierarchical: {
		      enabled:true,
		      levelSeparation: 150,
		      nodeSpacing: 100,
		      treeSpacing: 200,
		      blockShifting: true,
		      edgeMinimization: false,
		      parentCentralization: true,
		      direction: &apos;UD&apos;,        // UD, DU, LR, RL
		      sortMethod: &apos;directed&apos;   // hubsize, directed
		    }
		},
		interaction:{
		    zoomView: false,
		    navigationButtons: true,
	      	keyboard: true
		}
	};


     /**
     * This method is called whenever a node or an edge was double clicked.
     * It opens the edge or the node dialog.
     *
     * @param {Object} params - The parameters from the vis.js double click event. Further information: http://visjs.org/docs/network/
     * @param {Object} network - The actual network, which is displayed in the query builder.
     */
	self.onDoubleClick = function(params, network){
		var openNodeDialog = false;
		var openEdgeDialog = false;
		if(params.nodes.length &gt; 0){
			 openNodeDialog = true;
		}
		else if(params.edges.length &gt; 0){
			 openEdgeDialog = true;
		}
		
		if(openNodeDialog){
			self.openNodeDialog (params, network);
		}

		if(!openNodeDialog &amp;&amp; openEdgeDialog){
			self.openEdgeDialog (params, network);
		}
	}
	/**
     * This method is called whenever a node or an edge was selected.
     * It saves the selected node and the selected edge.
	 *
     * @param {Object} params - The parameters from the vis.js Select click event. Further information: http://visjs.org/docs/network/
     * @param {Object} network - The actual network, which is displayed in the query builder.
     */
	self.onSelectClick = function(params, network){
		if(params.nodes.length &gt; 0){
			self.selectedNode = self.nodeIDStore[params.nodes[0]];
		}
		else {
			self.selectedNode = undefined;
		}

		if(params.edges.length &gt; 0){
			self.selectedRelation = self.relationshipIDStore[params.edges[0]];
		}
		else {
			self.selectedRelation = undefined;
		}

		$scope.$apply();
	}


   /********
   Dilaog in vis.js
   *********/
   /**
    *
    * This method checks whether the brackets of the filter attributes were set correctly.
    * e.g. There must be as many opening brackets as closing brackets. One cannot start with a closing
    * bracket.
    * 
    * @param {Object} filterAttributes - The filter attributes.
    * @return {string} Returns a list of wrong attributes (attributes where the brackets were not set correctly). 
    */
   self.checkBrackets = function(filterAttributes){
		var wrongAttributesNames = &quot;&quot;;
		if(filterAttributes != undefined){

	   		for (var i = 0; i &lt; filterAttributes.length; i++) {	

				var bracketCount = 0;

				if(filterAttributes[i].filters != undefined){
					for (var k = 0; k &lt; filterAttributes[i].filters.length; k++) {
		    			if(filterAttributes[i].filters[k].isBracketOpen){
		    				bracketCount = bracketCount +1;
		    			}
						if(filterAttributes[i].filters[k].isBracketClosed){
		    				bracketCount = bracketCount - 1;
		    			}

		    			if(bracketCount &lt; 0){
		    				break;
		    			}
		    		}	
				}   

				if(bracketCount != 0){
					if(wrongAttributesNames != &quot;&quot;){
						wrongAttributesNames = wrongAttributesNames + &quot;, &quot;;
					}
					wrongAttributesNames  = wrongAttributesNames + filterAttributes[i].attributeName;
				} 		
			}
	    }
	    return wrongAttributesNames;
   }

      /**
     * This method opens a new node dialog.
     * In order to find the right node, it uses the id provided by vis.js.
     * With this id the actual node can by found based on the self.nodeIDStore.
     *
     * @param {Object} params - The parameters from the vis.js click event. Further information: http://visjs.org/docs/network/
     * @param {Object} network - The actual network, which is displayed in the query builder.
     */
    self.openNodeDialog = function(params, network){
    	var $network = network;
    	var params = params;
    	var node = self.nodeIDStore[params[&quot;nodes&quot;][0]];

    	var dialog = ngDialog.open({ template: &apos;querybuilder/nodeDialogTemplate.html&apos;,
        				className: &apos;ngdialog-theme-default custom-width&apos;,
        				controller: &apos;queryBuilderNodeDialogCtrl&apos;,
        				controllerAs: &apos;ctrl&apos;,
        				data: 
                        {
                            &quot;node&quot;: node,
                            &quot;author&quot;: self.query.author
                        }
                    });


	    dialog.closePromise.then(function (data) {
	    	
	    	var wrongAttributesNames = self.checkBrackets(node.filterAttributes);
	    	
	    	if(wrongAttributesNames != &quot;&quot;){
	    		var $dataForDialog = {
					&quot;head&quot;:&quot;Error on closing&quot;,
					&quot;content&quot;:&quot;Wrong brackes in filter: &quot; + wrongAttributesNames
				};

				var infoClosePromis = function(data){
					self.openNodeDialog(params, $network);
				}
				self.showInfoDialog($dataForDialog, infoClosePromis);
	    		
	    	}
	    	self.onQueryChanged();
			self.transfersToGraph($network);
			 
		});
    };

     /**
     * This method opens a new relationship dialog.
     * In order to find the right relationship, it uses the id provided by vis.js.
     * With this id the actual relationship can by found based on the self.relationshipIDStore.
     *
     * @param {Object} params - The parameters from the vis.js click event. Further information: http://visjs.org/docs/network/
     * @param {Object} network - The actual network, which is displayed in the query builder.
     */
    self.openEdgeDialog = function(params, network){
    		 var edgeId =params[&quot;edges&quot;][0];
    		 var relationship =  self.relationshipIDStore[edgeId];
    		 var params = params;
    		 var $network = network;

	         var dialog = ngDialog.open({ template: &apos;querybuilder/relationshipDialogTemplate.html&apos;,
	        				className: &apos;ngdialog-theme-default custom-width&apos;,
	        				controller: &apos;queryBuilderRelationshipDialogCtrl&apos;,
	        				controllerAs: &apos;ctrl&apos;,
	        				data:
                            {
                                &quot;relationship&quot;: relationship,
                                &quot;author&quot;: self.query.author
                            }
                        });


	        dialog.closePromise.then(function (data) {
			    
		    	var wrongAttributesNames = self.checkBrackets(relationship.filterAttributes);
		    	
		    	if(wrongAttributesNames != &quot;&quot;){
		    		var $dataForDialog = {
						&quot;head&quot;:&quot;Error on closing&quot;,
						&quot;content&quot;:&quot;Wrong brackes in filter: &quot; + wrongAttributesNames
					};

					var infoClosePromis = function(data){
						self.openEdgeDialog(params, $network);
					}
					self.showInfoDialog($dataForDialog, infoClosePromis);
		    		
		    	}
		    	self.onQueryChanged();
				self.transfersToGraph($network);
			});
    }

	/**
	 * Loads the old query from $rootScope if it is available.
	 * If there is no old query available then load the nodes to initialize the query.
	 */
	if($rootScope.queryBuilderOldQuery !== undefined){
        self.loadQueryLogic($rootScope.queryBuilderOldQuery);
    }
    else{
    	$requests.getNodes(self.getNodesCB);
    }


     /**
      * This property holdes if a user is allowed to edit the query.
      * @type {boolean}  if the user is allowed to edit.
      */ 
      self.hasPermissions = (self.query.author === $rootScope.principal.username);


}]);</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>

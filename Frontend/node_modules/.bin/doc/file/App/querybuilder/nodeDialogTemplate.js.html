<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">App/querybuilder/nodeDialogTemplate.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  </ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">App/querybuilder/nodeDialogTemplate.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use strict&apos;;

angular.module(&apos;queryBuilder.querybuildernodedialog&apos;, [&apos;ngRoute&apos;])


	/**
   * The controller which handles the configuration of a node.
   * It will be opened when a node will be clicked.
   *
   * In general, this controller helps to add or remove return attributes,
   * orderby attributes and filter attributes.
   * Every certain key (attribute) of a node can have a return, orderby or 
   * filter attribute. If such a attribute is required the json will be 
   * added with the set method.
   * The possible attributes are first loaded into the keys array.
   * 
   * @version 1.0.0
   */
.controller(&apos;queryBuilderNodeDialogCtrl&apos;, [&apos;$requests&apos;, &apos;$scope&apos;, &apos;$rootScope&apos;,&apos;ngDialog&apos;,
    function($requests, $scope, $rootScope, ngDialog) {
        var self = this;
	    
	     /**
	     * The property contains all informations about the node.
	     * This information is handed in from the query builder.
	     * @type {Object}
	     */	
        self.node = $scope.ngDialogData.node;

           /**
         * The property contains the author of the query in which the
         * relationship is contained.
         * This information is handed in from the query builder.
         * @type {Object}
         */ 
        self.author = $scope.ngDialogData.author;

         /**
	     * The name of the node.
	     * @type {Object}
	     */	
        self.name = self.node[&apos;type&apos;];
         /**
	     *The keys are all possible attributes where one can apply a filter.
	     * @type {Object}
	     */	
        self.keys = [];
         /**
	     * The relations are all existing incoming and outgoing relationship types of a 
         * certain node.
	     * @type {Object}
	     */	
        self.relationships = [];

        /**
        * The callback when the requested keys were loaded.
        * The keys are all possible attributes where one can apply a filter.
        *
        * @param {boolean} $success - true when there are no errors.
        * @param {Object} $data - the requested data (In this case the keys).
        * @param {number} $status - the actual server status.
        */
		self.getKeysCB = function($success, $data, $status){
			self.hasError = !$success;
			if($success){
				self.keys = $data; 
			}
		};
		 /**
         * This method loads all keys.
         * The keys are all possible attributes where one can apply a filter, set it as return attribue or
         * order the results according to it.
         */
		$requests.getKeys(self.node[&apos;type&apos;], self.getKeysCB);

		
		/**
        * The callback when the requested relations were loaded.
        * The relations are all existing incoming and outgoing relationship types of this 
        *  node.
        *
        * @param {boolean} $success - true when there are no errors.
        * @param {Object} $data - the requested data (In this case the relations).
        * @param {number} $status - the actual server status.
        */
		self.getRelationsWithNodesCB = function($success, $data, $status){
			self.hasError = !$success;
			if($success){
				self.relationships = $data; 
			}
		};

		 /**
         * This method loads all relations.
         * The relations are all existing incoming and outgoing relationship types of 
         * this node.
         */
		$requests.getRelationsWithNodes(self.node[&apos;type&apos;], self.getRelationsWithNodesCB);


		/******************************
		ADD RELATIONSHIP
		/******************************/

		/**
        * This method adds an relationship to this node.
        *
        * @param {string} $type - the relationshiptype.
        * @param {string} $direction - The direction of the relationship (ingoing or outgoing).
        * @param {Object} $node - The node type where the relationship comes from ore goes to.
        */
		self.addRelationship = function($type, $direction, $node){
			self.node[&apos;relationship&apos;].push({
					&quot;relationshipType&quot; :$type, 	//hasMethod, hasInstance
					&quot;direction&quot;: $direction, 	//ingoing, outgoing
					&quot;optional&quot;:false, 			//OPTIONAL MATCH
					&quot;returnAttributes&quot;:[],
					&quot;filterAttributes&quot;:[],
					&quot;orderByAttributes&quot;:[],
					&quot;node&quot;: {
						&quot;type&quot;: $node,
						&quot;returnAttributes&quot;: [],
						&quot;filterAttributes&quot;: [],
						&quot;orderByAttributes&quot;: [],
						&quot;relationship&quot;:[]
					}
				}
			);

		}

		/**
	    * This method opens an info dialog. It displays a certain data (head and content)
	    * given in the $data. Furthermore, a callback can be specified, when the dialg is closed.
	    *
	    * @param {!Object} $data - the head an the content for the info dialog.
	    * @param {?function} infoClosePromis - The function which should be called when the dialog is closed.
	    */
	    self.showInfoDialog = function($data, infoClosePromis){
	    	var dialog = ngDialog.open({ template: &apos;querybuilder/infoDialog.html&apos;,
	        				className: &apos;ngdialog-theme-default custom-width&apos;,
	        				controller: &apos;querybuilderInfoDialogCtrl&apos;,
	        				controllerAs: &apos;ctrl&apos;,
	        				data:$data
	        		 });
	    	if(infoClosePromis !== undefined){
	    		dialog.closePromise.then(infoClosePromis);
	    	}
	    }

		/******************************
		Return Attributes
		/******************************/

		/**
        * This method searches for a certain return attribute with a certain the attribute name.
        *
        * @param {string} $key - The key of the return attribute. The key is the same as the attribute name.
        * @return {Object} The given return attribute or undefined.
        */
		self.getReturnAttributes = function($key){
			var returnAttribute = undefined;
			for (var i = self.node[&apos;returnAttributes&apos;].length - 1; i &gt;= 0; i--) {
				if(self.node[&apos;returnAttributes&apos;][i][&apos;attributeName&apos;] === $key){
					returnAttribute = self.node[&apos;returnAttributes&apos;][i];
					break;
				}
			}
			return returnAttribute;
		};

		/**
        * Checks whether a certain return attribute with a certain key (attribute name) exists or not.
        *
        * @param {string} $key - The return attribute key. The key is the same as the attribute name.
        * @return {boolean} True if the attribute with the given key exists, otherwise false.
        */
		self.isReturnAttributesChecked = function($key){
			if(self.getReturnAttributes($key) === undefined){
				return false;
			}
			return true;
		};
		/**
        * Checks whether a certain return attribute with a certain key exists or not.
        * If it exists it removes the return attribute, if not it creates a return attribute with 
        * the given key. 
        * Every call toggles a certain return attribute with a certain key.
        * This is necessary because only the keys which should be returned should have an 
        * entry in the returnAttributes array. For one key (attribute name)
        * there can be only one return attribute.
        *
        * @param {string} $key - The key of the property which should be added or deleted.
        */
		self.setReturnAttributes = function($key){
			var returnAttribute = self.getReturnAttributes($key);
			if(returnAttribute !== undefined){
				//Deletes the return attribute
				var index = self.node[&apos;returnAttributes&apos;].indexOf(returnAttribute);
				self.node[&apos;returnAttributes&apos;].splice(index, 1);	

				if(self.getOrderByAttributes($key) !== undefined){
					self.setOrderByAttributes($key);
				}
			}
			else
			{
				//adds a return attribute
				self.node[&apos;returnAttributes&apos;].push({
					&quot;attributeName&quot;:$key,
					&quot;alias&quot;:&quot;&quot;,
					&quot;aggregation&quot; : &quot;NONE&quot;
				});
			}
		};

		/**
        * This method sets a property of a certain return attribute identified by 
        * the key (attribute name).
        *
        * @param {string} $key - The key of the return attribute. The key is the same as the attribute name.
        * @param {string} $type - The property which should be set. 
        * @param {Object} $value - The characteristic of the property ($type).
        */
		self.setReturnAttributesValue = function($key, $type, $value){
			var returnAttribute = self.getReturnAttributes($key);
			if(returnAttribute !== undefined){
				returnAttribute[$type] = $value;
			}
		};

		/******************************
		ORDER BY ATTRIBUTES 
		/******************************/

		/**
        * This method searches for a certain orderby attribute with a certain attribute name (key).
        *
        * @param {string} $key - The key of the orderby attribute. The key is the same as the attribute name.
        * @return {Object} The given orderby attribute or undefined.
        */
		self.getOrderByAttributes = function($key){
			var orderByAttribute = undefined;
			for (var i = self.node[&apos;orderByAttributes&apos;].length - 1; i &gt;= 0; i--) {
				if(self.node[&apos;orderByAttributes&apos;][i][&apos;attributeName&apos;] === $key){
					orderByAttribute = self.node[&apos;orderByAttributes&apos;][i];
					break;
				}
			}
			return orderByAttribute;
		};

		/**
        * Checks whether a certain orberby attribute with a certain key (attribute name) exists or not.
        *
        * @param {string} $key - The orberby attribute key. The key is the same as the attribute name.
        * @return {boolean} True if the attribute with the given key exists, otherwise false.
        */
		self.isOrderByAttributesChecked = function($key){
			if(self.getOrderByAttributes($key) === undefined){
				return false;
			}
			return true;
		};

		/**
        * Checks whether a certain orberby attribute with a certain key exists or not.
        * If it exists it removes the orberby attribute, if not it creates a orberby attribute with 
        * the given key. 
        * Every call toggles a certain orberby attribute with a certain key.
        * This is necessary because only the keys which should be returned should have an 
        * entry in the returnAttributes array. For one key (attribute name)
        * there can be only one orberby attribute.
        *
        * @param {string} $key - The key of the property which should be added or deleted.
        */
		self.setOrderByAttributes = function($key){
			var orderByAttribute = self.getOrderByAttributes($key);
			//Toggle attribute
			if(orderByAttribute !== undefined){
				//Deletes the orderby attribute
				var index = self.node[&apos;orderByAttributes&apos;].indexOf(orderByAttribute);
				self.node[&apos;orderByAttributes&apos;].splice(index, 1);	
			}
			else
			{
				if(self.getReturnAttributes($key) === undefined){
					self.setReturnAttributes($key);
				}
				//Adds the orderby attribute
				self.node[&apos;orderByAttributes&apos;].push({
					&quot;attributeName&quot;:$key,
					&quot;id&quot;: 1,
					&quot;direction&quot;: &quot;asc&quot;
				});
			}
		};

		/**
        * This method sets a property of a certain orderby attribute identified by 
        * the key (attribute name).
        *
        * @param {string} $key - The key of the orderby attribute. The key is the same as the attribute name.
        * @param {string} $type - The property which should be set. 
        * @param {Object} $value - The characteristic of the property ($type).
        */
		self.setOrderByAttributesValue = function($key, $type, $value){
			var orderByAttribute = self.getOrderByAttributes($key);
			if(orderByAttribute !== undefined){
				orderByAttribute[$type] = $value;
			}
		};
	

		/******************************
		FILTER ATTRIBUTES
		/******************************/
		/**
        * This method searches for a certain filter attribute with a certain attribute name (key).
        *
        * @param {string} $key - The key of the filter attribute. The key is the same as the attribute name.
        * @return {Object} The given filter attribute or undefined.
        */
		self.getFilterAttributes = function($key){	
			for (var i = self.node[&apos;filterAttributes&apos;].length - 1; i &gt;= 0; i--) {
				if(self.node[&apos;filterAttributes&apos;][i][&apos;attributeName&apos;] === $key){
					return self.node[&apos;filterAttributes&apos;][i];
					
				}
			}
			return undefined;
		};

		/**
        * Checks whether a certain filter attribute with a certain key (attribute name) exists or not.
        *
        * @param {string} $key - The filter attribute key. The key is the same as the attribute name.
        * @return {boolean} True if the attribute with the given key exists, otherwise false.
        */
		self.isFilterAttributesChecked = function($key){
			if(self.getFilterAttributes($key) === undefined){
				return false;
			}
			return true;
		};
		/**
        * Checks whether a certain filter attribute with a certain key exists or not.
        * If it exists it removes the filter attribute, if not it creates a filter attribute with 
        * the given key. 
        * Every call toggles a certain filter attribute with a certain key.
        * This is necessary because only the keys which should be returned should have an 
        * entry in the returnAttributes array. For one key (attribute name)
        * there can be only one filter attribute.
		*
		* Because a filter attribute can also have relations between each other, this 
		* method handles the relations by setting the logic attribute. If two attributes are
		* combined by this logic, the first holds the logic.
		* 
		* If a new attribute is added, 
		* this method also adds the logic to the previous attribute. 
		* If the last attribute is removed the logic
		* of the attribute before it is also removed.
		* 
        * This works because the filter attributes are ordered alphabetically.
        * 
        * @param {string} $key - The key of the property which should be added or deleted.
        */
		self.setFilterAttributes = function($key){
			var filterAttribute = self.getFilterAttributes($key);
			if(filterAttribute !== undefined){
				
				var index = self.node[&apos;filterAttributes&apos;].indexOf(filterAttribute);
				
				if(self.node[&apos;filterAttributes&apos;].length - 1 === index &amp;&amp; index !== 0){
					self.node[&apos;filterAttributes&apos;][index - 1].logic = &quot;&quot;;
				}
				self.node[&apos;filterAttributes&apos;].splice(index, 1);	
			}
			else
			{
				
				var newFilterAttribute = {
						&quot;attributeName&quot;:$key,
						&quot;logic&quot;:&quot;&quot;,
						&quot;filters&quot;: [
							{
								&quot;id&quot;:0,			//for Frontend
								&quot;type&quot;:&quot;string&quot;,		 //int, string...
								&quot;filterType&quot;: &quot;=&quot;, 	// &quot;in&quot;,&quot;like&quot;,&quot;=&quot;,&quot;&gt;&quot;
								&quot;value&quot;:&quot;&quot;, 
								&quot;changeable&quot;:true,
								&quot;isBracketOpen&quot;: false,
								&quot;isBracketClosed&quot;: false,
								&quot;logic&quot;:&quot;&quot;  			//&#x201C;AND/OR&#x201D;
							}
						]	//ist der Parameter fix oder in der Verwaltung ver&#xE4;nderbar?
				};

				//adds and attribute
				self.node[&apos;filterAttributes&apos;].push(
					newFilterAttribute
				);
				//sort alphabetically
				self.node[&apos;filterAttributes&apos;] = self.node[&apos;filterAttributes&apos;].sort(function(x, y) {
			        if (x[&apos;attributeName&apos;] == y[&apos;attributeName&apos;]) return 0;
			        else if (x[&apos;attributeName&apos;] &lt; y[&apos;attributeName&apos;]) return -1;
			        else return 1;
			    });
				//add logic to index +1 and index - 1 if not available
			    var index = self.node[&apos;filterAttributes&apos;].indexOf(newFilterAttribute);

			    if(index &gt; 0){
					if(self.node[&apos;filterAttributes&apos;][index - 1].logic === &quot;&quot; ||
						self.node[&apos;filterAttributes&apos;][index - 1].logic === undefined){
						self.node[&apos;filterAttributes&apos;][index - 1].logic = &quot;AND&quot;;
					};
				}
				if(self.node[&apos;filterAttributes&apos;].length - 1 &gt; index  ){
					self.node[&apos;filterAttributes&apos;][index].logic = &quot;AND&quot;;
				}
			}
			console.log(self.node);
		};

		/**
        * This method sets a property of a certain filter attribute identified by 
        * the key (attribute name).
        *
        * @param {string} $key - The key of the filter attribute. The key is the same as the attribute name.
        * @param {string} $type - The property which should be set. 
        * @param {Object} $value - The characteristic of the property ($type).
        */
		self.setFilterAttributesValue = function($key, $type, $value){
			var filterAttributes = self.getFilterAttributes($key);

			if(filterAttributes != undefined
				&amp;&amp; filterAttributes[$type] !== $value){
				filterAttributes[$type] = $value;
			}

			console.log(&quot;Set key: &quot; + $key + &quot;, type: &quot; + $type + 
							&quot;, value: &quot; + $value );
		};

		/**
        * A filter attribute contains multiple (at least one) filter. Each filter is 
        * identified by an id. 
        * This method searches for a certain filter identified by an id
        * in a certain filter attribute identified a certain attribute name (key).
        *
        * @param {string} $key - The key of the filter attribute. The key is the same as the attribute name.
        * @param {string} $id - The id of the specific filter. 
        * @return {Object} The given filter attribute or undefined.
        */
		self.getFilterAttributesFilter = function($key, $id){
			var filterAttributes = self.getFilterAttributes($key);

			if(filterAttributes !== undefined &amp;&amp; 
				filterAttributes.filters !== undefined){
				for (var i = filterAttributes.filters.length - 1; i &gt;= 0; i--) {
					if(filterAttributes.filters[i].id === $id){
						return filterAttributes.filters[i];	
					}
				}
			}

			return undefined;
		}

		
		/**
        * This method sets a property of a certain filter identified by an id in
        * a certain filter attribute identified by an attribute name (key).
        *
        * @param {string} $key - The key of the filter attribute. The key is the same as the attribute name.
        * @param {string} $id - The id of the specific filter. 
        * @param {string} $type - The property which should be set. 
        * @param {Object} $value - The characteristic of the property ($type).
        */
		self.setFilterAttributesFilterValue = function($key, $id, $type, $value){
			var filterAttributesFilter = self.getFilterAttributesFilter($key, $id);

			if(filterAttributesFilter != undefined
				&amp;&amp; filterAttributesFilter[$type] !== $value){
				filterAttributesFilter[$type] = $value;

				if($type === &apos;type&apos;){
					filterAttributesFilter[&apos;value&apos;] = undefined; 
				}
			}

			console.log(&quot;Set key: &quot; + $key + &quot;, type: &quot; + $type + 
							+ &quot;, id: &quot; + $id + &quot;, value: &quot; + $value );
		};

		/**
        * This method adds a filter to a filter attribute.
        * The new filter will have a unique id.
        * This method also sorts the filter attributes by the id.
        * The filter attributes were combined with a certain logic (AND, OR) within  
        * a certain filter attributes. This method initializes also the logic.
        *
        * @param {string} $key - The key of the filter attribute in which the filter should be added.
        */
		self.addFilterAttributesFilter = function($key){

			var filterAttributes = self.getFilterAttributes($key);

			if(	filterAttributes !== undefined &amp;&amp;
				filterAttributes !== null &amp;&amp;
				filterAttributes.filters !== undefined &amp;&amp;
				filterAttributes.filters !== null ){
				//sort filters ascending
				filterAttributes.filters.sort(function(x, y) {
			        if (x[&apos;id&apos;] == y[&apos;id&apos;]) return 0;
			        else if (parseInt(x[&apos;id&apos;]) &lt; parseInt(y[&apos;id&apos;])) return -1;
			        else return 1;
			    });
				//there must be at least one filter in the filters array
				//otherwise: invalid state

				if(filterAttributes.filters.length &gt; 0){
					filterAttributes.filters[filterAttributes.filters.length - 1].logic = &quot;AND&quot;;
				}

				var id = filterAttributes.filters[filterAttributes.filters.length - 1].id;
				id = id +1;
				filterAttributes.filters.push(
				{
					&quot;id&quot;:id,			//for Frontend
					&quot;type&quot;:&quot;string&quot;,	//int, string...
					&quot;filterType&quot;: &quot;=&quot;, 	//like &quot;in&quot;,&quot;like&quot;,&quot;=&quot;,&quot;&gt;&quot;
					&quot;value&quot;:&quot;&quot;, 
					&quot;changeable&quot;:false,
					&quot;isBracketOpen&quot;: false,
					&quot;isBracketClosed&quot;: false,
					&quot;logic&quot;:&quot;&quot;  		//&#x201C;AND/OR&#x201D;
				});
			}
		}


		/**
        * This method removes a filter identified by an id of a filter attribute
        * identified by the attribute name (key).
        *
        * The filter attributes werew combined with a certain logic (AND, OR). 
        * If required, this method deletes this logic too.
        *
        * @param {string} $key - The key of the filter attribute in which the filter should be removed.
        * @param {string} $id - The id of the specific filter which should be removed. 
        */
		self.deleteFilterAttributesFilter = function($key, $id){
			var filterAttributes = self.getFilterAttributes($key);

			if(filterAttributes !== undefined){
				//There must be at least one filter in the array
				if(filterAttributes.filters != undefined &amp;&amp;
					filterAttributes.filters.length &gt; 1){
					//Delete filter
					var filterAttributesFilter = self.getFilterAttributesFilter($key, $id);
					if(filterAttributesFilter != undefined){
						var index = filterAttributes.filters.indexOf(filterAttributesFilter);
						if(filterAttributes.filters.length - 1 === index &amp;&amp; index !== 0){
							filterAttributes.filters[index - 1].logic = &quot;&quot;;
						}

						filterAttributes.filters.splice(index, 1);	
					}
				}	
			}
		}

		 /**
         * This function checks wheather a user has the  
         * permission to edit the items or not.
         *
         * @param {string} $attributeType - The type of the attribute -&gt; &quot;filter&quot;, &quot;return&quot;, &quot;orderby&quot;
         * @param {string} $key - The key of the attribute for which the permissions should be cheked. 
         * @param {Object} $additionalInfo - Additional informations.
         * @return {boolean} Returns optional property.
         */ 
        self.hasPermissions = function($attributeType, $key, $additionalInfo){
            if(self.author === $rootScope.principal.username){
            	//the author can do everything
                return true;
            }
            else {
            	//permission is only granted to filter attributes
            	if($attributeType === &quot;filter&quot; &amp;&amp; $additionalInfo != undefined &amp;&amp;
            		$additionalInfo.type != undefined &amp;&amp; $additionalInfo.id != undefined &amp;&amp;
            		$additionalInfo.type != &quot;changeable&quot;){

            		var filterAttributesFilter = self.getFilterAttributesFilter($key, $additionalInfo.id);
            		if(filterAttributesFilter.changeable){
            			return true;
            		}
            		return false;
            		
            	}
                return false;
            }
        }
}]);
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>

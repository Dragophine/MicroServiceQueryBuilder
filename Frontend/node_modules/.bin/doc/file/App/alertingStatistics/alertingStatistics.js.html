<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">App/alertingStatistics/alertingStatistics.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  </ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">App/alertingStatistics/alertingStatistics.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use strict&apos;;

angular.module(&apos;queryBuilder.alertingStatistics&apos;, [&apos;ngRoute&apos;, &apos;queryBuilder.services&apos;])

.config([&apos;$routeProvider&apos;, function($routeProvider) {
  $routeProvider.when(&apos;/alertingStatistics&apos;, {
    templateUrl: &apos;alertingStatistics/alertingStatistics.html&apos;
  });
}])
/**
   * This controller handles the main operation in the user interface.
   * It configures and handle all actions in the alert statistic view.  
   * 
   * @version 1.0.0
   */
.controller(&apos;alertingStatisticsCtrl&apos;, [&apos;$requests&apos;,
	function($requests) {
	var self = this;
	
    /**
     * Holds selected alert name.
     * @type {string}
     */
	self.selectedAlert = &quot;&quot;;
    /**
     * Stores all dates between min and max date and all counts per day from selected alert.
     * @type {array}
     */
	self.alertDateAndCount = [];
	/**
	 * Load google charts
	 */
	google.charts.load(&apos;current&apos;, {packages: [&apos;corechart&apos;, &apos;line&apos;]});
	google.charts.setOnLoadCallback(drawBasic);

	/**
	 * Draw a chart with Google charts. The chart shows how many alerts occured per day.
	 * The graph shows the period from the first occurrence of an alert to the last appearance 
	 * of an alert.
	 */
	function drawBasic() {

	      var data = new google.visualization.DataTable();
	      data.addColumn(&apos;date&apos;, &apos;Date&apos;);
	      data.addColumn(&apos;number&apos;, &apos;Alerts&apos;);
	      
	      var i;
	      for (i=0; i&lt;self.alertDateAndCount.length; i++) {
	    	  data.addRow(new Array (new Date (self.alertDateAndCount[i].date), self.alertDateAndCount[i].counts));
	      }

	      var options = {
	        hAxis: {
	          title: &apos;Date&apos;,
	          format: &apos;d/M/yy&apos;
	        },
	        vAxis: {
	          title: &apos;Alerts&apos;,
	          format: &apos;#,###&apos;,
	          minValue: 0
	        }
	      };

	      var chart = new google.visualization.LineChart(document.getElementById(&apos;chart_div&apos;));

	      chart.draw(data, options);
	    }
	
	/**
	 * Callback from get all alerts call. If query was successful show chart for first alert.
	 * Otherwise print error.
	 *
	 * @param {boolean} $success - true when there are no errors.
	 * @param {Object} $data - the requested data (In this case the alerts).
     * @param {number} $status - the actual server status.
	 */
	self.getAlertsCB = function($success, $data, $status) {
		self.hasError = !$success;
		if($success){
			self.existingAlerts = $data;
			if(self.existingAlerts != null &amp;&amp; self.existingAlerts.length &gt; 0)
			{
				// default selection -&gt; first alert in array
				self.selectedAlert = self.existingAlerts[0].name;
				var firstQuery = self.existingAlerts[0];				
				getDataFromAlert(firstQuery);
			}			
		}
		else
		{
			self.error = $data;
		}
	}
	/**
	 * When the view is called, all alerts with all data are read from graph DB once,
	 * no other read tasks necessary.
	 */
	$requests.getAllAlertNames(self.getAlertsCB);

	/**
	 * User select another alert in comboBox.
	 */
	self.selectAlert = function()
	{
		self.alertDateAndCount = [];
		var x;
		var firstQuery;
		for(x=0; x&lt;self.existingAlerts.length; x++)
		{
			if(self.selectedAlert == self.existingAlerts[x].name)
			{
				firstQuery = self.existingAlerts[x];
				break;
			}
		}
		getDataFromAlert(firstQuery);
	}
	
	/**
	 * This method evaluates the timestamp data. A two-dimensional array is generated that contains
	 * all days from the first appearance of an alert to the last appearance of an alert. The number
	 * of times an alert occurs per day is also counted and stored in the array.
	 * 
     * @param {number} $selectedAlert - the alert which should be shown in chart.
	 */
	function getDataFromAlert($selectedAlert)
	{
		if($selectedAlert != null)
		{
			var zwischenergebnis = [];
			var results = {}, i, date;

			var minDate;
			var maxDate;
			// count alerts per date, get min and max date
			for (i=0; i&lt;$selectedAlert.dates.length; i++) {
			  // get the date without timezone offset
				var d = new Date($selectedAlert.dates[i]);
				d = new Date(d.valueOf() + d.getTimezoneOffset() * 60000);
			  date = [d.getFullYear(),d.getMonth()+1,d.getDate()].join(&quot;-&quot;);
			  results[date] = results[date] || 0;
			  results[date]++;
			  
			  if(minDate == null || minDate &gt; date)
			  {
				  minDate = date;
			  }
			  if(maxDate == null || maxDate &lt; date)
			  {
				  maxDate = date;
			  }
			}
			
			// generate array with all values between min and max date
			var newDates = [],
		    currentDate = new Date(minDate),
		    d;
			var maximumDate = new Date(maxDate);

			while (currentDate &lt;= maximumDate) {
			    var dateFormat = currentDate.getFullYear() + &apos;-&apos; + (currentDate.getMonth() + 1) + &apos;-&apos; + currentDate.getDate();
			    
			    if(results[dateFormat] == null || results[dateFormat] == 0)
		    	{
			    	zwischenergebnis[dateFormat] = 0;
		    	}
			    else
		    	{
			    	zwischenergebnis[dateFormat] = results[dateFormat];
		    	}
			    
			    currentDate.setDate(currentDate.getDate() + 1);
			}

			// create a two dimensional array with date and count data
			for (i in zwischenergebnis) {
			  if (zwischenergebnis.hasOwnProperty(i)) {
				  self.alertDateAndCount.push({date:i,counts:zwischenergebnis[i]});
			  }
			}
			// redraw chart
			drawBasic();
		}
	}
}]);</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
